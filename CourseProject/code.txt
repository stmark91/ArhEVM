--------Function main--------
----------------main.c----------------
#include "./../include/mainHeader.h"

extern int accumulator;
extern int instructionPointer;
extern int writeUsed;
extern int writeValue;
extern int bigChars[];
extern int SCANPRINTRADIX;
extern int position;
extern int cursorX;
extern int cursorY;

struct itimerval val, oval;

int main(int argc, char** argv){
  sc_memoryInit();
  sc_regInit();
  setSignals();
  rk_mytermsave();
  sc_regSet(FLAG_INTERRUPT, 1);
  int position = 0, fd = 0, cn = 0, tmp = 0, exit = 0, refreshFlg = 0, regis = 0, regisProg = 0;
  enum keys key  = KEY_other;
  if ((fd = open("bigchars.bin", O_RDONLY)) == -1) {
    writeChar(2,"Cannot open ascibig\n");
    return -1;
  }
  bc_bigcharread(fd, bigChars, 17, &cn);
  close(fd);
  mt_clrscr();
  refreshGuiSt(position);
  while (!exit) {
    if (!refreshFlg) {
      refreshGui(position);
      refreshFlg = 1;
    }
    rk_readkey(&key);
    sc_regGet(FLAG_INTERRUPT, &regisProg);
    if(regisProg) {
      switch (key) {
        case KEY_up:
          if (cursorY != 0) cursorY--;
            else cursorY = 9;
          refreshFlg = 0;
          key  = KEY_other;
        break;
        case KEY_down:
          cursorY = (cursorY + 1) % 10;
          refreshFlg = 0;
          key  = KEY_other;
        break;
        case KEY_left:
          if (cursorX != 0) cursorX--;
            else cursorX = 9;
          refreshFlg = 0;
          key  = KEY_other;
        break;
        case KEY_right:
          cursorX = (cursorX + 1) % 10;
          refreshFlg = 0;
          key  = KEY_other;
        break;
        case KEY_f5:
          refreshFlg = changeAccumulator(position);
          key  = KEY_other;
        break;
        case KEY_f6:
          refreshFlg = changeInstructionPointer(position);
          key  = KEY_other;
        break;
        case KEY_enter:
          refreshFlg = changeCell(position);
          key  = KEY_other;
        break;
        case KEY_t:
          CU();
          refreshGui(instructionPointer);
          position = instructionPointer;
          cursorX = instructionPointer / 10;
          cursorY = instructionPointer % 10;
          key  = KEY_other;
        break;
        case KEY_s:
          memorySave(position);
          refreshFlg = 1;
          key  = KEY_other;
        break;
        case KEY_l:
          memoryLoad(position);
          refreshFlg = 1;
          key  = KEY_other;
        break;
        case KEY_i:
          raise(SIGUSR1);
          refreshFlg = 0;
          cursorX = 0;
          cursorY = 0;
          key  = KEY_other;
        break;
        case KEY_q:
          exit = 1;
          key  = KEY_other;
        break;
      }
    }
    if (key == KEY_c) {
      position = instructionPointer;
      cursorX = instructionPointer / 10;
      cursorY = instructionPointer % 10;
      refreshFlg = 0;
      raise(SIGUSR2);
      key  = KEY_other;
    } else if (key == KEY_esc) {
      raise(SIGTERM);
      key  = KEY_other;
    } else if (key == KEY_r) {
      key = KEY_other;
      sc_regGet(FLAG_INTERRUPT, &regis);
      if (regis) {
        sc_regInit();
        frequencyGenerator(START);
        position = instructionPointer;
        cursorX = instructionPointer / 10;
        cursorY = instructionPointer % 10;
        refreshFlg = 0;
        continue;
      } else {
        frequencyGenerator(STOP);
        sc_regSet(FLAG_INTERRUPT, 1);
        position = instructionPointer;
        cursorX = instructionPointer / 10 ;
        cursorY = instructionPointer % 10;
        refreshFlg = 0;
        continue;
	    }
    }
    position = cursorY + cursorX * 10;
  }
  frequencyGenerator(STOP);
  rk_mytermrestore();
  signalsRestore();
  system("rm -f termsettings");
  return 0;
}
--------libSimpleComputer.a--------
----------------global.c----------------
#include "./../include/sc.h"

int localRAM[sizeRAM];
short int sc_register;
int correctCommands[countCmd] = { 0x10, 0x11, 0x20, 0x21, 0x30, 0x31, 0x32,
                                  0x33, 0x40, 0x41, 0x42, 0x43, 0x51, 0x52,
                                  0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
                                  0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
                                  0x67, 0x68, 0x69, 0x70, 0x71, 0x72, 0x73,
                                  0x74, 0x75, 0x76 };
----------------sc_memory.c----------------
#include "./../include/sc_memory.h"
#include "./../include/sc_register.h"

extern int localRAM[];

int sc_memoryInit(void){
  for (int i = 0; i < sizeRAM; i++) localRAM[i] = 0;
  return 0;
}

int sc_memorySet(int addres, int value){
  if ((addres < sizeRAM) & (addres >= 0)) {
    localRAM[addres] = value;
    return 0;
  } else {
    sc_regSet(FLAG_OUTMEM, 1);
    return ERR_WRONG_ADDR;
  }
}

int sc_memoryGet(int addres, int* value){
  if ((addres < sizeRAM) & (addres >=0) & (value != NULL)) {
    *value = localRAM[addres];
    return 0;
  } else {
    sc_regSet(FLAG_OUTMEM, 1);
    return ERR_WRONG_ADDR;
  }
}

volatile int sc_memorySave(char* filename){
  int data = 0, writecount  = 0;
  if ((data = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666)) == -1)
    return ERR_OPEN_FILE;
  writecount = write(data, localRAM, sizeof(int) * sizeRAM);
  close(data);
  if (writecount != sizeof(int) * sizeRAM) return ERR_FILE;
    else return 0;
}

volatile int sc_memoryLoad(char* filename){
  int data = 0, readcount = 0, i = 0;
  int ram[sizeRAM] = {0};
  if ((data = open(filename, O_RDONLY)) == -1) return ERR_OPEN_FILE;
  readcount = read(data, ram, sizeof(int) * sizeRAM);
  close(data);
  for (i = 0; i < sizeRAM; i++) ram[i] &= 0x7FFF;
  if (readcount != sizeof(int) * sizeRAM) return ERR_FILE;
    else for (i = 0; i < sizeRAM; i++) localRAM[i] = ram[i];
  return 0;
}
----------------sc_register.c----------------
#include "./../include/sc_register.h"

extern short int sc_register;

int sc_regInit(void){
  sc_register = 0;
  return 0;
}

int sc_regSet(int scRegister, int value){
  if ((scRegister >= 0) & (scRegister <=5))
    if (value == 1) BITSET(sc_register, scRegister);
      else if (value == 0) BITCLEAR(sc_register, scRegister);
        else return ERR_WRONG_FLAG;
  else return ERR_WRONG_FLAG;
  return 0;
}

int sc_regGet(int scRegister, int* value){
  if ((scRegister >= 0) & (scRegister <=5))
    *value = BITCHECK(sc_register, scRegister);
  else return ERR_WRONG_FLAG;
  return 0;
}
----------------sc_command.c----------------
#include "./../include/sc_command.h"
#include "./../include/sc_register.h"

extern int correctCommands[];

int sc_commandEncode(int command, int operand, int* value){
  int i = 0, *commandPtr = NULL;
  for (i = 0; i < countCmd; i++)
    if (command == correctCommands[i]) commandPtr = &(correctCommands[i]);
  if (commandPtr != NULL) {
    if (operand > 0x7F) {
      operand &= 0x7F;
      sc_regSet(FLAG_OVERFLOW,1);
    }
    if (value != NULL) {
      *value = ((command << 7) | operand) & 0x3FFF;
      return 0;
    }
  } else {
    sc_regSet(FLAG_COMMAND, 1);
    return ERR_UNCORRECT_COMMAND;
  }
  return ERR_WRONG_ADDR;
}

int sc_commandDecode(int value, int* command, int* operand){
  int *correctCommand  = NULL;
  int attribute = (value >> 14) & 1, tmpCommand = 0, tmpOperand = 0, i = 0;
  if (value == 0) {
    *command = 0;
    *operand = 0;
    return 2;
  }
  if (command != NULL & operand != NULL) {
    if (attribute == 0) {
      tmpCommand = (value >> 7) & 0x7F;
      tmpOperand = value & 0x7F;
      for (i = 0; i < countCmd; i ++) {
        if (tmpCommand == correctCommands[i]) {
          correctCommand = &(correctCommands[i]);
        }
      }
      if (!(correctCommand == NULL)) {
        *command = tmpCommand;
        *operand = tmpOperand;
      } else {
        sc_regSet(FLAG_COMMAND, 1);
        return ERR_UNCORRECT_COMMAND;
      }
      return 0;
    } else {
      return ERR_ATTRIBUTE_BIT;
    }
  }
  return 0;
}
----------------sc.h----------------
#ifndef SC_H
#define SC_H

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

#define sizeRAM  100
#define countCmd 38

#define FLAG_OVERFLOW  0
#define FLAG_DIVISION  1
#define FLAG_OUTMEM    2
#define FLAG_INTERRUPT 3
#define FLAG_COMMAND   4
#define FLAG_ODD       5

#define ERR_WRONG_ADDR        -1
#define ERR_OPEN_FILE         -2
#define ERR_FILE              -3
#define ERR_UNCORRECT_COMMAND -4
#define ERR_ATTRIBUTE_BIT     -5
#define ERR_WRONG_FLAG        -6

#define BITSET(A, B) (A =((A) | (1 << (B))))
#define BITCLEAR(A, B) (A = ((A) & ~(1 << (B))))
#define BITCHECK(A, B) (((A) >> B) & 1)

#endif
----------------sc_memory.h----------------
#ifndef SC_MEMORY_H
#define SC_MEMORY_H

#include "./sc.h"

int sc_memoryInit(void);
int sc_memorySet(int addres, int value);
int sc_memoryGet(int addres, int* value);
volatile int sc_memorySave(char* filename);
volatile int sc_memoryLoad(char* filename);

#endif
----------------sc_register.h----------------
#ifndef SC_REGISTER_H
#define SC_REGISTER_H

#include "./sc.h"

int sc_regInit(void);
int sc_regSet(int sc_register, int value);
int sc_regGet(int sc_register, int* value);

#endif
----------------sc_command.h----------------
#ifndef SC_COMMAND_H
#define SC_COMMAND_H

#include "./sc.h"

int sc_commandEncode(int command, int operand, int* value);
int sc_commandDecode(int value, int* command, int* operand);

#endif
--------libTerm.a--------
----------------term.c----------------
#include "./../include/term.h"

int mt_clrscr(){
  writeChar(1, "\E[H\E[2J");
  return 0;
}

int mt_gotoXY(int x, int y){
  int rows = 0, cols = 0;
  mt_getscreensize(&rows, &cols);
  if (((y < rows) & (y >= 0)) & ((x < cols) & (x >= 0))) {
    writeChar(1, "\E[");
    writeInt(1, y, 10, -1);
    writeChar(1, ";");
    writeInt(1, x, 10, -1);
    writeChar(1, "H");
    return 0;
  } else return -1;
}

int mt_getscreensize(int *rows, int *cols){
  struct winsize w;
  if (!ioctl(STDOUT_FILENO, TIOCGWINSZ, &w)) {
    *rows = w.ws_row;
    *cols = w.ws_col;
    return 0;
  }  else return -1;
}

int mt_setfgcolor(enum colors color){
  if (color >= 0 & color <= 9) {
    writeChar(1, "\E[");
    writeInt(1, 30 + color, 10, -1);
    writeChar(1, "m");
    return 0;
  } else return -1;
}

int mt_setbgcolor(enum colors color){
  if (color >= 0 & color <= 9) {
    writeChar(1, "\E[");
    writeInt(1, 40 + color, 10, -1);
    writeChar(1, "m");
    return 0;
  } else return -1;
}
----------------term.h----------------
#ifndef CONSOLE_SC_H
#define CONSOLE_SC_H

#include <sys/ioctl.h>
#include "./../../print/include/write.h"

enum colors {
	clr_black      = 0,
	clr_red        = 1,
	clr_green      = 2,
	clr_yellow     = 3,
	clr_blue       = 4,
	clr_purple     = 5,
	clr_cyan       = 6,
	clr_light_blue = 7,
	clr_default    = 9
};

int mt_clrscr();
int mt_gotoXY(int x, int y);
int mt_getscreensize(int *rows, int *cols);
int mt_setfgcolor(enum colors color);
int mt_setbgcolor(enum colors color);

#endif
--------libBigChars.a--------
----------------bc.c----------------
#include "./../include/bc.h"

static void swap(int* a, int* b){
  int tmp = 0;
  tmp = *a;
  *a = *b;
  *b = tmp;
}

int bc_printA(char *str){
  writeChar(1, "\E(0");
  write(1, str, strlen(str));
  writeChar(1, "\E(B");
  return 0;
}

int bc_box(int x1, int y1, int x2, int y2){
  int maxx = 0, maxy = 0, i = 0, j = 0;
  if (x1 > x2) swap(&x1, &x2);
  if (y1 > y2) swap(&y1, &y2);
  mt_getscreensize(&maxy, &maxx);
  if ((x1 < 0) | (y1 < 0) | (x2 > maxx) | (y2 > maxy) | (x2 - x1 < 2) |
      (y2 - y1 < 2))
    return -1;
  mt_gotoXY(x1, y1);
  bc_printA(BOXCHAR_TL);
  for (i = x1 + 1; i < x2; i++) bc_printA(BOXCHAR_HOR);
  bc_printA(BOXCHAR_TR);
  for (i = y1 +1; i < y2; i++) {
    mt_gotoXY(x1, i);
    bc_printA(BOXCHAR_VERT);
    mt_gotoXY(x2, i);
    bc_printA(BOXCHAR_VERT);
  }
  mt_gotoXY(x1, y2);
  bc_printA(BOXCHAR_BL);
  for (i = x1 + 1; i < x2; i++) bc_printA(BOXCHAR_HOR);
  bc_printA(BOXCHAR_BR);
  return 0;
}

int bc_printbigchar(int *big, int x, int y, enum colors fg, enum colors bg){
  int pos = 0, bit = 0, maxx = 0, maxy = 0, i = 0, j = 0;
  char row[9] = {0};
  mt_getscreensize(&maxy, &maxx);
  if ((x < 0) | (y < 0) | (x + 8 > maxx) | (y + 8 > maxy)) return -1;
  row[8] = '\0';
  mt_setfgcolor(fg);
  mt_setbgcolor(bg);
  for (i = 0; i < 8; i++) {
    for (j = 0; j < 8; j++) {
      pos = i >> 2;
      bit = (big[pos] >> ((i % 4) * 8 + j)) & 1;
      if (bit == 0) row[j] = ' ';
        else row[j] = BOXCHAR_REC;
    }
    mt_gotoXY(x, y + i);
    bc_printA(row);
  }
  mt_setfgcolor(clr_default);
  mt_setbgcolor(clr_default);
  return 0;
}

int bc_setbigcharpos(int *big, int x, int y, int value){
  int pos = 0;
  if ((x < 0) | (y < 0) | (x > 7) | (y > 7) | (value < 0) | (value > 1)) return -1;
  if (y <= 3) pos = 0;
    else pos = 1;
  y = y % 4;
  if (value == 0) big[pos] &= ~(1 << (y*8 + x));
    else big[pos] |= 1 << (y*8 + x);
  return 0;
}

int bc_getbigcharpos(int *big, int x, int y, int *value){
  int pos = 0;
  if ((x < 0) | (y < 0) | (x > 7) | (y > 7)) return -1;
  if (y <= 3) pos = 0;
    else pos = 1;
  y = y % 4;
  *value = (big[pos] >> (y*8 + x)) & 1;
  return 0;
}

int bc_bigcharwrite(int fd, int *big, int count){
  int err = 0;
  err = write(fd, &count, sizeof(count));
  if (err == -1) return -1;
  err = write(fd, big, count * sizeof(int) * 2);
  if (err == -1) return -1;
  return 0;
}

int bc_bigcharread(int fd, int *big, int need_count, int *count){
  int n, cnt, err;
  err = read(fd, &n, sizeof(n));
  if ((err == -1) | (err != sizeof(n))) return -1;
  cnt = read(fd, big, need_count * sizeof(int) * 2);
  if (cnt == -1) return -1;
  *count = cnt / (sizeof(int) * 2);
  return 0;
}
----------------bc.h----------------
#ifndef BC_H
#define BC_H

#include "./../../consoleSC/include/term.h"
#include "./../../print/include/write.h"

#define BOXCHAR_REC 'a'
#define BOXCHAR_BR "j"
#define BOXCHAR_BL "m"
#define BOXCHAR_TR "k"
#define BOXCHAR_TL "l"
#define BOXCHAR_VERT "x"
#define BOXCHAR_HOR "q"

static void swap(int* a, int* b);
int bc_printA(char *str);
int bc_box(int x1, int y1, int x2, int y2);
int bc_printbigchar(int *big, int x, int y, enum colors fg, enum colors bg);
int bc_setbigcharpos(int *big, int x, int y, int value);
int bc_getbigcharpos(int *big, int x, int y, int *value);
int bc_bigcharwrite(int fd, int *big, int count);
int bc_bigcharread(int fd, int *big, int need_count, int *count);

#endif
--------libReadKey.a--------
----------------readkey.c----------------
#include "./../include/readkey.h"
/*
  tcflag_t c_iflag;      // режимы ввода
  tcflag_t c_oflag;      // режимы вывода
  tcflag_t c_cflag;      // режимы управления
  tcflag_t c_lflag;      // режимы локали
  cc_t c_cc[NCCS];       // управляющие символы
  c_iflag - флаги констант:
*/
int rk_readkey(enum keys *key){
  struct termios orig_options;
  char buf[16] = {0};
  int readNum  = 0;
  if (tcgetattr(STDIN_FILENO, &orig_options) != 0) return -1;
  if (rk_mytermregime(0, 0, 1, 0, 1) != 0) return -1;
  readNum = read(STDIN_FILENO, buf, 5);
  if (readNum <= 0) return -1;
  buf[readNum] = '\0';
  if ((strcmp(buf, "l") == 0) | (strcmp(buf, "L") == 0)) {
    *key = KEY_l;
  } else if ((strcmp(buf, "s") == 0) | (strcmp(buf, "S") == 0)) {
    *key = KEY_s;
  } else if ((strcmp(buf, "r") == 0) | (strcmp(buf, "R") == 0)) {
    *key = KEY_r;
  } else if ((strcmp(buf, "t") == 0) | (strcmp(buf, "T") == 0)) {
    *key = KEY_t;
  } else if ((strcmp(buf, "i") == 0) | (strcmp(buf, "I") == 0)) {
    *key = KEY_i;
  } else if ((strcmp(buf, "q") == 0) | (strcmp(buf, "Q") == 0)) {
    *key = KEY_q;
  } else if ((strcmp(buf, "x") == 0) | (strcmp(buf, "X") == 0)) {
    *key = KEY_x;
  } else if ((strcmp(buf, "d") == 0) | (strcmp(buf, "D") == 0)) {
    *key = KEY_d;
  } else if ((strcmp(buf, "c") == 0) | (strcmp(buf, "C") == 0)) {
    *key = KEY_c;
  } else if ((strcmp(buf, "\n")) == 0) {
    *key = KEY_enter;
  } else if ((strcmp(buf, "\E[15~")) == 0) {
    *key = KEY_f5;
  } else if ((strcmp(buf, "\E[17~")) == 0) {
    *key = KEY_f6;
  } else if ((strcmp(buf, "\E[A")) == 0) {
    *key = KEY_up;
  } else if ((strcmp(buf, "\E[B")) == 0) {
    *key = KEY_down;
  } else if ((strcmp(buf, "\E[C")) == 0) {
    *key = KEY_right;
  } else if ((strcmp(buf, "\E[D")) == 0) {
    *key = KEY_left;
  } else if ((strcmp(buf, "\E")) == 0) {
    *key = KEY_esc;
  } else {
    *key = KEY_other;
  }
  if (tcsetattr(STDIN_FILENO, TCSANOW, &orig_options) != 0) return -1;
  return 0;
}

int rk_mytermsave(void){
  struct termios options;
  FILE *save = NULL;
  if (tcgetattr(STDIN_FILENO, &options) != 0) return -1;
  if ((save = fopen("termsettings", "wb")) == NULL) return -1;
  fwrite(&options, sizeof(options), 1, save);
  fclose(save);
  return 0;
}

int rk_mytermrestore(void){
  struct termios options;
  FILE *data = NULL;;
  if ((data = fopen("termsettings", "rb")) == NULL) return -1;
  else {
    if (fread(&options, sizeof(options), 1, data) > 0) {
      if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &options) != 0) {
        fclose(data);
        return -1;
      } else {
        fclose(data);
        return -1;
      }
    }
    fclose(data);
  }
  return 0;
}

int rk_mytermregime(int regime, int vtime, int vmin, int echo, int sigint){
  struct termios options;
  if (tcgetattr(STDIN_FILENO, &options) != 0) return -1;
  if (regime == 1) options.c_lflag |= ICANON;
    else if (regime == 0) options.c_lflag &= ~ICANON;
      else return -1;
  if (regime == 0) {
    options.c_cc[VTIME] = vtime;
    options.c_cc[VMIN] = vmin;
    if (echo == 1) options.c_lflag |= ECHO;
      else if (echo == 0) options.c_lflag &= ~ECHO;
        else return -1;
    if (sigint == 1) options.c_lflag |= ISIG;
      else if (sigint == 0) options.c_lflag &= ~ISIG;
        else return -1;
  }
  if (tcsetattr(STDIN_FILENO, TCSANOW, &options) != 0) return -1;
  return 0;
}
----------------readkey.h----------------
#ifndef READ_KEY_H
#define READ_KEY_H

#include "./../../simpleComputer/include/sc_register.h"
#include "./../../simpleComputer/include/sc_command.h"
#include "./../../simpleComputer/include/sc_memory.h"
#include "./../../bc/include/bc.h"
#include "./../../consoleSC/include/term.h"

#include <termios.h>
#include <string.h>

enum keys {
  KEY_l = 0,
  KEY_s,
  KEY_r,
  KEY_t,
  KEY_i,
  KEY_x,
  KEY_d,
  KEY_c,
  KEY_q,
  KEY_f5,
  KEY_f6,
  KEY_up,
  KEY_down,
  KEY_left,
  KEY_right,
  KEY_enter,
  KEY_esc,
  KEY_other
};

int rk_readkey(enum keys *key);
int rk_mytermsave(void);
int rk_mytermrestore(void);
int rk_mytermregime(int regime, int vtime, int vmin, int echo, int sigint);

#endif
--------libCPU.a--------
----------------cpu.c----------------
#include "./../include/cpu.h"

extern int accumulator;
extern int instructionPointer;

void CU(){
  int command, operand, mem;
  if (instructionPointer >= sizeRAM) {
    sc_regSet(FLAG_OUTMEM, 1);
    sc_regSet(FLAG_INTERRUPT, 1);
    refreshGui(instructionPointer);
    instructionPointer = 0;
    return;
  }
  sc_memoryGet(instructionPointer, &mem);
  if (!(sc_commandDecode(mem, &command, &operand)
      == 0)) {
    sc_regSet(FLAG_COMMAND, 1);
    sc_regSet(FLAG_INTERRUPT, 1);
    return;
  }
  if ((operand < 0) | (operand >= sizeRAM)) {
    sc_regSet(FLAG_COMMAND, 1);
    sc_regSet(FLAG_INTERRUPT, 1);
    return;
  }
  if ((command >= 0x30) & (command <= 0x33) |
      (command >= 0x51) & (command <= 0x54) |
      (command >= 0x60) & (command <= 0x70) |
      (command >= 0x75) & (command <= 0x76)) {
    if (ALU(command, operand) != 0)
      sc_regSet(FLAG_INTERRUPT, 1);
  } else commandHandler(command, operand);
  instructionPointer++;
}

int ALU(int command, int operand){
  if ((operand < 0) | (operand >= sizeRAM)) {
    sc_regSet(FLAG_OUTMEM,1);
    return ERR_WRONG_ADDR;
  } else {
    if (commandHandler(command, operand) != 0) return -1;
    if ((accumulator > 0x3FFF)) {
      accumulator &= 0x3FFF;
      sc_regSet(FLAG_OVERFLOW, 1);
    } else sc_regSet(FLAG_OVERFLOW, 0);
    sc_regSet(FLAG_ODD, accumulator & 1);
    return 0;
  }
}
----------------print.c----------------
#include "./../include/cpu.h"

extern int accumulator;
extern int instructionPointer;
extern int bigChars[];
extern int writeValue;
extern int writeUse;
extern int SCANPRINTRADIX;
static int counterRefresh = 0;

static void printWriteValue(){
  int command = 0, opcode  = 0, operand = 0;
  mt_gotoXY(1, 23);
  printLine(3);
  mt_gotoXY(1, 23);
  command = (writeValue >> 14) & 1;
  if (writeUse != 0) {
    writeChar(1,"Last write: ");
    if (command == 0) {
      sc_commandDecode(writeValue, &opcode, &operand);
      writeChar(1,"+");
      writeInt(1, opcode, 16, 2);
      writeInt(1, operand, 16, 2);
    } else {
      writeChar(1," ");
      writeInt(1, writeValue & 0x3FFF, SCANPRINTRADIX, 4);
    }
  }
}

void printLine(int ctr){
  int x = 0, y = 0;
  mt_getscreensize(&y, &x);
  for (int j = 0; j < ctr; j++) {
    for (int i = 0; i < x; i++)
      writeChar(1," ");
    writeChar(1,"\n");
  }
}

void refreshGuiSt(int position){
  mt_clrscr();
  printBoxes();
  printLabels();
  printKeys(48, 14);
  printPointer();
  printAccum();
  printOperation(position);
  printMemory(2, 2, position);
  printFlags(66, 11);
  printWriteValue();
  mt_gotoXY(1, 23);
}

void refreshGui(int position){
  counterRefresh++;
  if (counterRefresh % REFRESH == 0) {
    refreshGuiSt(position);
    counterRefresh = 0;
  } else {
    printPointer();
    printAccum();
    printOperation(position);
    printMemory(2, 2, position);
    printFlags(66, 11);
    printWriteValue();
    mt_gotoXY(1, 23);
  }
}

void printAccum(){
  mt_setfgcolor(ACCUMCOLORFG);
  mt_gotoXY(68, 2);
  writeChar(1, "     ");
  mt_gotoXY(68, 2);
  if (SCANPRINTRADIX == 16)writeInt(1, accumulator & 0x3FFF, SCANPRINTRADIX, 4);
    else if (SCANPRINTRADIX == 10) writeInt(1, accumulator & 0x3FFF, SCANPRINTRADIX, 5);
  mt_setfgcolor(clr_default);
}

void printBoxes(){
  bc_box(1, 1, 61, 12);
  bc_box(62, 1, 79, 3);
  bc_box(62, 4, 79, 6);
  bc_box(62, 7, 79, 9);
  bc_box(62, 10, 79, 12);
  bc_box(1, 13, 46, 22);
  bc_box(47, 13, 79, 22);
}

void printPointer(){
  mt_gotoXY(68, 5);
  mt_setfgcolor(INSTREGCOLORFG);
  writeInt(1, instructionPointer, SCANPRINTRADIX, 4);
  mt_setfgcolor(clr_default);
}

void printKeys(int x, int y){
  mt_setfgcolor(KEYCOLORFG);
  mt_gotoXY(x, y);
  writeChar(1, "l  - load    | c   - stop");
  mt_gotoXY(x, y + 1);
  writeChar(1, "s  - save");
  mt_gotoXY(x, y + 2);
  writeChar(1, "r  - run ");
  mt_gotoXY(x, y + 3);
  writeChar(1, "t  - step");
  mt_gotoXY(x, y + 4);
  writeChar(1, "i  - reset");
  mt_gotoXY(x, y + 5);
  writeChar(1, "F5 - accumulator");
  mt_gotoXY(x, y + 6);
  writeChar(1, "F6 - instruction Pointer");
  mt_gotoXY(x, y + 7);
  writeChar(1, "q  - quit");
  mt_setfgcolor(clr_default);
}

void printLabels(){
  mt_setfgcolor(KEYCOLORFG);
  mt_gotoXY(30, 1);
  writeChar(1, " Memory ");
  mt_gotoXY(64, 1);
  writeChar(1, " accumulator ");
  mt_gotoXY(65, 4);
  writeChar(1, " instPointer ");
  mt_gotoXY(65, 7);
  writeChar(1, " Operation ");
  mt_gotoXY(67, 10);
  writeChar(1, " Flags ");
  mt_gotoXY(48, 13);
  writeChar(1, " Keys: ");
  mt_gotoXY(2, 22);
  writeChar(1, " Input/Output ");
  mt_setfgcolor(clr_default);
}

void printOperation(int position){
  int mem = 0, command   = 0, operand   = 0, isCommand;
  char c = '+';
  if ((position >= sizeRAM) & (position <= 0)) {
    sc_regSet(FLAG_OUTMEM, 1);
    return;
  }
  sc_memoryGet(position, &mem);
  isCommand = (mem >> 14) & 1;
  mt_gotoXY(68, 8);
  if ((position >= 0) & (position < sizeRAM)) {
    if (isCommand == 0) {
      sc_commandDecode(mem, &command, &operand);
      writeChar(1, "        ");
      mt_gotoXY(68, 8);
      mt_setfgcolor(COMMANDCOLORFG);
      write(1, &c, 1);
      writeInt(1, command, 16, 2);
      writeChar(1, " : ");
      mt_setfgcolor(OPERANDCOLORFG);
      writeInt(1, operand, 16, 2);
      mt_setfgcolor(clr_default);
    } else {
      mt_setfgcolor(COMMANDCOLORFG);
      writeChar(1, "        ");
      mt_gotoXY(68, 8);
      writeInt(1, mem & 0x3FFF, 16, 4);
      mt_setfgcolor(clr_default);
    }
  }
}

void printFlags(int x, int y){
  int reg = 0;
  mt_gotoXY(x, y);
  sc_regGet(FLAG_OVERFLOW, &reg);
  if (reg == 1) {
    mt_setfgcolor(REGCOLORFG);
    writeChar(1, "O");
    mt_setfgcolor(clr_default);
  } else writeChar(1, " ");
  writeChar(1, " ");
  sc_regGet(FLAG_COMMAND, &reg);
  if (reg == 1) {
    mt_setfgcolor(REGCOLORFG);
    writeChar(1, "E");
    mt_setfgcolor(clr_default);
  } else writeChar(1, " ");
  writeChar(1, " ");
  sc_regGet(FLAG_INTERRUPT, &reg);
  if (reg == 1) {
    mt_setfgcolor(REGCOLORFG);
    writeChar(1, "T");
    mt_setfgcolor(clr_default);
  } else writeChar(1, " ");
  writeChar(1, " ");
  sc_regGet(FLAG_OUTMEM, &reg);
  if (reg == 1) {
    mt_setfgcolor(REGCOLORFG);
    writeChar(1, "M");
    mt_setfgcolor(clr_default);
  } else writeChar(1, " ");
  writeChar(1, " ");
  sc_regGet(FLAG_DIVISION, &reg);
  if (reg == 1) {
    mt_setfgcolor(REGCOLORFG);
    writeChar(1, "Z");
    mt_setfgcolor(clr_default);
  } else writeChar(1, " ");
}

int printMcell(int *bigchars, int pos){
  int command = 0, mem = 0, opcode = 0, operand = 0, indexBigChar = 0;
  char str[10] = {0}, c = 0;
  if ((pos >= sizeRAM) & (pos < 0)) {
    sc_regSet(FLAG_OUTMEM, 1);
    return 1;
  }
  sc_memoryGet(pos, &mem);
  command = (mem >> 14) & 1;
  mem &= 0x3FFF;
  if (command == 0) {
    sc_commandDecode(mem, &opcode, &operand);
    str[0] = '+';
    swriteInt(str + 1, opcode, 16, 2);
    swriteInt(str + 3, operand, 16, 2);
  } else {
    str[0] = ' ';
    swriteInt(str + 1, mem, 16, 4);
  }
  for (int i = 0; i < 5; i++) {
    mt_gotoXY(2 + 9 * i, 14);
    indexBigChar = (str[i] == '+') ? 0 : (((str[i] >= '0') && (str[i] <= '9'))
                                          ? (str[i] - '0' + 1)
                                          : ((str[i] >= 'A') &&
                                             (str[i] <= 'F'))
                                             ? (str[i] - 'A' + 11) : -1);
    bc_printbigchar(bigchars + (indexBigChar * 2), 2 + i*9, 14, BIGCHARSCOLORFG,
                      BIGCHARSCOLORBG);
  }
  return 0;
}

void printMemory(int x, int y, int position){
  int mem = 0, command = 0, opcode = 0, operand = 0;
  if ((position >= sizeRAM) & (position < 0)) {
    sc_regSet(FLAG_OUTMEM, 1);
    return;
  }
  for (int i = 0; i < 10; i++) {
    mt_gotoXY(x, y + i);
    for (int j = 0; j < 10; j++) {
      sc_memoryGet(i + j * 10, &mem);
      command = (mem >> 14) & 1;
      mem &= 0x3FFF;
      if ((i + j * 10 ) == position) {
        mt_setfgcolor(TEXTCOLORFG);
        mt_setbgcolor(TEXTCOLORBG);
      }
      if ((i + j * 10 ) == instructionPointer) mt_setfgcolor(INSTREGCOLORFG);
      if (command == 0) {
        int ret = sc_commandDecode(mem, &opcode, &operand);
        writeChar(1, "+");
        writeInt(1, opcode, 16, 2);
        writeInt(1, operand, 16, 2);
      } else if (command == 1) {
        writeChar(1, " ");
        writeInt(1, mem, 16, 4);
      }
      if ((i + j * 10) == position) {
        mt_setfgcolor(clr_default);
        mt_setbgcolor(clr_default);
      }
      if ((i + j * 10 ) == instructionPointer) mt_setfgcolor(clr_default);
      if (j != 9) writeChar(1, " ");
    }
  }
  printMcell(bigChars, position);
}
----------------handlers.c----------------
#include "./../include/cpu.h"

extern int accumulator;
extern int instructionPointer;
extern int writeUse;

void timerHand(int sig){
  int reg;
  sc_regGet(FLAG_INTERRUPT, &reg);
  if (reg == 0) {
    CU();
    refreshGui(instructionPointer);
  }
}

void ursignalHand(int sig){
  sc_memoryInit();
  sc_regInit();
  sc_regSet(FLAG_INTERRUPT, 1);
  accumulator = 0;
  writeUse = 0;
  instructionPointer = 0;
}

void ursignalHand2(int sig){
  setitimer(TIMER, NULL, NULL);
  sc_regSet(FLAG_INTERRUPT, 1);
}

void windHand(int sig){
  refreshGuiSt(0);
}

void killHand(int sig){
  setitimer(TIMER, NULL, NULL);
  mt_clrscr();
  rk_mytermrestore();
  signalsRestore();
  system("rm -f termsettings");
  exit(0);
}
----------------command.c----------------
#include "./../include/cpu.h"

extern int accumulator;
extern int instructionPointer;
extern int writeUse;
extern int writeValue;
extern int position;
extern int cursorX;
extern int cursorY;

int commandHandler(int command, int operand){
  int tmp    = 0;
  int tmpMem = 0;
  int flag   = 0;

  switch (command) {
    case 0x10: /* READ */
      while (readMcell(operand) != 0);
    break;
    case 0x11: /* WRITE */
      writeUse = 1;
      if (sc_memoryGet(operand, &writeValue) != 0) return -1;
    break;
    case 0x20: /* LOAD */
      if (sc_memoryGet(operand, &accumulator) != 0) return -1;
      accumulator &= 0x3FFF;
    break;
    case 0x21: /* STORE */
      tmp = accumulator | (1 << 14);
      if (sc_memorySet(operand, tmp) != 0) return -1;
    break;
    case 0x30: /* ADD */
      if (sc_memoryGet(operand, &tmpMem) != 0) return -1;
      tmpMem &= 0x3FFF;
      if (accumulator + tmpMem > 0x3FFF) {
        sc_regSet(FLAG_OVERFLOW, 1);
        accumulator += tmpMem;
        accumulator &= 0x3FFF;
      } else accumulator += tmpMem;
    break;
    case 0x31: /* SUB */
      if (sc_memoryGet(operand, &tmpMem) != 0) return -1;
      tmpMem &= 0x3FFF;
      accumulator -= tmpMem;
    break;
    case 0x32: /* DIV */
      if (sc_memoryGet(operand, &tmpMem) != 0) return -1;
      tmpMem &= 0x3FFF;
      if (!(tmpMem == 0)) accumulator = accumulator / tmpMem;
        else {
          sc_regSet(FLAG_DIVISION, 1);
          return -1;
        }
    break;
    case 0x33: /* MUL */
      if (sc_memoryGet(operand, &tmpMem) != 0) return -1;
      accumulator = accumulator * (tmpMem & 0x3FFF);
    break;
    case 0x40: /* JUMP */
      instructionPointer = operand - 1;
    break;
    case 0x41: /* JNEG */
      if (((accumulator >> 14) & 1) == 1) instructionPointer = operand - 1;
    break;
    case 0x42: /* JZ */
      if (accumulator == 0) instructionPointer = operand - 1;
    break;
    case 0x43: /* HALT */
      sc_regSet(FLAG_INTERRUPT, 1);
      instructionPointer--;
      position = instructionPointer;
      cursorX = instructionPointer / 10;
      cursorY = instructionPointer % 10;
      refreshGui(instructionPointer);
    break;
    case 0x51:  /* NOT */
      accumulator = ~accumulator;
      if (sc_memorySet(operand, accumulator) != 0) {
        return -1;
      }
    break;
    case 0x52:  /* AND */
      if (sc_memoryGet(operand, &tmpMem) != 0) {
        return -1;
      }

      tmp = tmpMem;
      if (tmp > 0x7FFF) {
        tmp = tmp & 0x7FFF;
      }
      accumulator = accumulator & tmp;
    break;
    case 0x53:  /* OR */
      if (sc_memoryGet(operand, &tmpMem) != 0) {
        return -1;
      }
      tmp = tmpMem;
      if (tmp > 0x7FFF) {
        tmp = tmp & 0x7FFF;
      }
      accumulator = accumulator | tmp;
    break;
    case 0x54:  /* XOR */
      if (sc_memoryGet(operand, &tmpMem) != 0) {
        return -1;
      }
      tmp = tmpMem;
      if (tmp > 0x7FFF) {
        tmp = tmp & 0x7FFF;
      }
      accumulator = accumulator ^ tmp;
    break;
    case 0x55:  /* JNS */
      if (accumulator > 0)
        instructionPointer = operand - 1;
    break;
    case 0x56:  /* JC */
      sc_regGet(FLAG_OVERFLOW, &flag);
      if (flag == 1) {
        instructionPointer = operand - 1;
      }
    break;
    case 0x57:  /* JNC */
      sc_regGet(FLAG_OVERFLOW, &flag);
      if (flag == 0) {
        instructionPointer = operand - 1;
      }
    break;
    case 0x58:  /* JP */
      sc_regGet(FLAG_ODD, &flag);
      if (flag == 0) {
        instructionPointer = operand - 1;
      }
    break;
    case 0x59: /* JNP */
      sc_regGet(FLAG_ODD, &flag);
      if (flag == 1) {
        instructionPointer = operand - 1;
      }
    break;
    case 0x60:  /* CHL */
      if (sc_memoryGet(operand, &tmpMem) != 0) {
        return -1;
      }
      if (tmpMem) {
        tmpMem = tmpMem << 1;
        tmpMem &= 0x7FFF;
      }
      accumulator = tmpMem;
    break;
    case 0x61:  /* SHR */
      if (sc_memoryGet(operand, &tmpMem) != 0) {
        return -1;
      }
      tmp = 0;
      if (tmpMem) {
        tmp = (tmpMem >> 14) & 1;
        tmpMem &= 0x3FFF;
        tmpMem = tmpMem >> 1;
      }
      accumulator = tmpMem | (tmp << 14);
    break;
    case 0x62:  /* RCL */
      if (sc_memoryGet(operand, &tmpMem) != 0) {
        return -1;
      }
      if (tmpMem) {
        tmp = (tmpMem >> 14) & 1;
        tmpMem = tmpMem << 1 | ((tmpMem >> 13) & 1);
        tmpMem = tmpMem | (tmp << 14);
        tmpMem &= 0x7FFF;
      }
      accumulator = tmpMem;
    break;
    case 0x63:  /* RCR */
      if (sc_memoryGet(operand, &tmpMem) != 0) {
        return -1;
      }
      if (tmpMem) {
        tmp = tmpMem & 1;
        tmpMem = tmpMem >> 1 | ((tmpMem & 1) << 13);
        tmpMem = tmpMem | (tmp << 14);
        tmpMem &= 0x7FFF;
      }
      accumulator = tmpMem;
    break;
    case 0x64:  /* NEG */
      if (sc_memoryGet(operand, &tmpMem) != 0) {
        return -1;
      }
      if (tmpMem) {
        tmpMem = (~tmpMem + 1);
        tmpMem &= 0x7FFF;
      }
      accumulator = tmpMem;
    break;
    case 0x65:  /* ADDC */
      if (sc_memoryGet(operand, &tmpMem) != 0) {
        return -1;
      }
      tmp = tmpMem;
      if (sc_memoryGet(accumulator, &tmpMem) != 0) {
        return -1;
      }
      if (tmp + tmpMem > 0x7FFF) {
        sc_regSet(FLAG_OVERFLOW, 1);
      } else {
        accumulator = tmp + tmpMem;
      }
    break;
    case 0x66:  /* SUBC */
      if (sc_memoryGet(operand, &tmpMem) != 0) {
        return -1;
      }
      tmp = tmpMem;
      if (sc_memoryGet(accumulator, &tmpMem) != 0) {
        return -1;
      }
      if (((tmpMem >> 14) & 1) == 1) {
        tmpMem = tmpMem | (~0x7FFF);
      } else {
        tmpMem = tmpMem;
      }
      accumulator = tmp - tmpMem;
      if ((accumulator > ((int)(~0x7FFF))) && (accumulator <= 0x7FFF)) {
        accumulator &= 0x7FFF;
      }
    break;
    case 0x67:  /* LOGLC */
      if (sc_memoryGet(operand, &tmpMem) != 0) {
        return -1;
      }

      if (tmpMem) {
        tmp = (accumulator >> 14) & 1;
        tmpMem &= 0x3FFF;
        accumulator = (tmpMem << accumulator) | (tmp << 14);
      } else {
        accumulator = tmpMem;
      }
    break;
    case 0x68:  /* LOGRC */
      if (sc_memoryGet(operand, &tmpMem) != 0) {
        return -1;
      }

      if (tmpMem) {
        tmp = (accumulator >> 14) & 1;
        tmpMem &= 0x3FFF;
        accumulator = tmpMem >> accumulator | (tmp << 14);
      } else {
        accumulator = tmpMem;
      }
    break;
    case 0x69:  /* RCCL */
      if (sc_memoryGet(operand, &tmpMem) != 0) {
        return -1;
      }
      if (tmpMem) {

        if (sc_memoryGet(accumulator, &tmp) != 0) {
          return -1;
        }

        int i = 0;
        for (i = 0; i < tmp; i ++) {
          tmpMem = (tmpMem << 1) & ((tmpMem >> 14) & 1);
        }
        accumulator = tmpMem;
        accumulator &= 0x7FFF;
      } else {
        accumulator = tmpMem;
        accumulator &= 0x7FFF;
      }
    break;
    case 0x70:  /* RCCR */
      if (sc_memoryGet(operand, &tmpMem) != 0) {
        return -1;
      }
      if (tmpMem) {
        if (sc_memoryGet(accumulator, &tmp) != 0) {
        return -1;
        }

        int i = 0;
        for (i = 0; i < tmp; i ++) {
          tmpMem = (tmpMem >> 1) & ((tmpMem & 1) << 14);
        }
        accumulator = tmpMem;
        accumulator &= 0x3FFF;
      } else {
        accumulator = tmpMem;
        accumulator &= 0x3FFF;
      }
    break;
    case 0x71:  /* MOVA */
      if (sc_memoryGet(operand, &tmpMem) != 0) {
        return -1;
      }
      if (accumulator == operand) {
        return -1;
      }

      if (sc_memorySet(accumulator, tmpMem) != 0) {
        return -1;
      }
      if (sc_memorySet(operand, 0) != 0) {
        return -1;
      }
    break;
    case 0x72:  /* MOVR */
      if (sc_memoryGet(accumulator, &tmpMem) != 0) {
        return -1;
      }
      if (accumulator == operand) {
        return -1;
      }
      if (sc_memorySet(operand, tmpMem) != 0) {
        return -1;
      }
      if (sc_memorySet(accumulator, 0) != 0) {
        return -1;
      }
    break;
    case 0x73:  /* MOVCA */
      if (sc_memoryGet(accumulator, &tmpMem) != 0) {
        return -1;
      }
      tmpMem &= 0x3FFF;
      if (tmpMem == operand) {
        return -1;
      }
      if (sc_memoryGet(operand, &tmp) != 0) {
        return -1;
      }

      if (sc_memorySet(tmpMem, tmp) != 0) {
        return -1;
      }
      if (sc_memorySet(operand, 0) != 0) {
        return -1;
      }
    break;
    case 0x74:  /* MOVCR */
      if (sc_memoryGet(accumulator, &tmpMem) != 0) {
        return -1;
      }
      tmpMem &= 0x3FFF;
      if (tmpMem == operand) {
        return -1;
      }

      if (sc_memoryGet(tmpMem, &tmp) != 0) {
        return -1;
      }

      if (sc_memorySet(operand, tmp) != 0) {
        return -1;
      }
      if (sc_memorySet(tmpMem, 0) != 0) {
        return -1;
      }
    break;
    case 0x75:  /* ADDC */
      if (sc_memoryGet(operand, &tmpMem) != 0) {
        return -1;
      }
      tmpMem &= 0x3FFF;

      tmp = tmpMem;
      if (sc_memoryGet(accumulator, &tmpMem) != 0) {
        return -1;
      }
      if (tmp + tmpMem > 0x7FFF) {
        sc_regSet(FLAG_OVERFLOW, 1);
      } else {
        accumulator = tmp + tmpMem;
      }
    break;
    case 0x76:  /* SUBC */
      if (sc_memoryGet(operand, &tmpMem) != 0) {
        return -1;
      }
      tmpMem &= 0x3FFF;

      tmp = tmpMem;

      if (sc_memoryGet(accumulator, &tmpMem) != 0) {
        return -1;
      }

      if (((tmpMem >> 14) & 1) == 1) {
        tmpMem = tmpMem | (~0x7FFF);
      } else {
        tmpMem = tmpMem;
      }
      accumulator = tmp - tmpMem;
      if ((accumulator > ((int)(~0x7FFF))) && (accumulator <= 0x7FFF)) {
        accumulator &= 0x7FFF;
      }
    break;
  }
  return 0;
}----------------change.c----------------
#include "./../include/cpu.h"

extern int accumulator;
extern int instructionPointer;
extern int SCANPRINTRADIX;
static struct sigaction act[5];
static struct sigaction old[5];
static sigset_t set;
static struct sigaction newalarm;
static struct sigaction oldalarm;
static sigset_t setalrm;
static struct termios originalTerm;
static int echoIgn = 0;
static int alarmIgn = 0;
extern int readUse;
static struct itimerval val;
static struct itimerval oval;

void frequencyGenerator (int status){
  if (status == START) {
    val.it_interval.tv_sec = TIMESLEEPSEC;
    val.it_interval.tv_usec = MKR(TIMESLEEPUSEC);
    val.it_value.tv_sec = TIMESLEEPSEC;
    val.it_value.tv_usec = MKR(TIMESLEEPUSEC);
    setitimer(TIMER, &val, &oval);
  } else if (status == STOP ) setitimer(TIMER, NULL, NULL);
}

void setSignals(){
  for (int i = 0; i < 5; i++) {
    memset(&(act[i]), 0, sizeof(act[i]));
    memset(&(old[i]), 0, sizeof(old[i]));
  }
  sigemptyset(&set);
  sigaddset(&set, SIGUSR1);
  sigaddset(&set, SIGALRM);
  act[0].sa_handler = timerHand;
  act[0].sa_mask = set;

  sigemptyset(&set);
  sigaddset(&set, SIGUSR1);
  act[1].sa_handler = ursignalHand;
  act[1].sa_mask = set;

  sigemptyset(&set);
  sigaddset(&set, SIGUSR1);
  sigaddset(&set, SIGUSR2);
  act[2].sa_handler = ursignalHand2;
  act[2].sa_mask = set;

  sigemptyset(&set);
  sigaddset(&set, SIGUSR1);
  sigaddset(&set, SIGWINCH);
  act[3].sa_handler = windHand;
  act[3].sa_mask = set;

  sigemptyset(&set);
  sigaddset(&set, SIGUSR1);
  sigaddset(&set, SIGTERM);
  act[4].sa_handler = killHand;
  act[4].sa_mask = set;

  //signal(SIGALRM, timerHand);
  //signal(SIGUSR1, ursignalHand1);
  //signal(SIGUSR2, ursignalHand2);
  //signal(SIGWINCH, windHand);
  //signal(SIGTERM, killHand);
  sigaction(SIGALRM, &(act[0]), &(old[0]));
  sigaction(SIGUSR1, &(act[1]), &(old[1]));
  sigaction(SIGUSR2, &(act[2]), &(old[2]));
  sigaction(SIGWINCH, &(act[3]), &(old[3]));
  sigaction(SIGTERM, &(act[4]), &(old[4]));
}

void signalsRestore(){
  sigemptyset(&set);
  sigaction(SIGALRM, &(old[0]), 0);
  sigaction(SIGUSR1, &(old[1]), 0);
  sigaction(SIGUSR2, &(old[2]), 0);
  sigaction(SIGWINCH, &(old[3]), 0);
  sigaction(SIGTERM, &(old[4]), 0);
}

void setIgnoreAlarm(){
  if (alarmIgn == 0) {
    newalarm.sa_handler = SIG_IGN;
    sigaction(SIGALRM, &(newalarm), &(oldalarm));
    alarmIgn = 1;
 } else return;
}

void restoreIgnoreAlarm(){
  if (alarmIgn == 1) {
    sigaction(SIGALRM, &(oldalarm), 0);
    alarmIgn = 0;
  } else return;
}

void setEchoRegime(){
  if (echoIgn == 0) {
    while (tcgetattr(STDIN_FILENO, &originalTerm) != 0);
    rk_mytermregime(0, 0, 1, 1, 1);
    echoIgn = 1;
  } else return;
}

void restoreEchoRegime(){
  if (echoIgn == 1) {
    while (tcsetattr(STDIN_FILENO, TCSANOW, &originalTerm) != 0);
    echoIgn = 0;
  } else return;
}

int changeCell(int pos){
  setEchoRegime();
  int plusFlag = 0, num = 0, command = 0, operand = 0, mem = 0;
  if (readUse == 0) {
    setIgnoreAlarm();
    refreshGui(pos);
    mt_gotoXY(1, 23);
    printLine(2);
    mt_gotoXY(1, 23);
    writeChar(1, "Enter num: ");
  }
  if (scanNum(&plusFlag, &num) != 0) {
    writeChar(2, "Not a number!");
    if (readUse == 0) restoreIgnoreAlarm();
    restoreEchoRegime();
    return -1;
  }
  if ((num >= 0) & (num < 0x8000)) {
    if (plusFlag) {
      command = (num >> 8) & 0x7F;
      if (num & 0x80) {
        writeChar(2, "Operand is 7 bit wide ( <= 7F). ");
        if (readUse == 0) restoreIgnoreAlarm();
        restoreEchoRegime();
        return -1;
      }
      operand = num & 0x7F;
      if (sc_commandEncode(command, operand, &mem) != 0) {
        writeChar(2, "Wrong command. Aborted. ");
        if (readUse == 0) restoreIgnoreAlarm();
        restoreEchoRegime();
        return -1;
      }
    } else {
      if (num >= 0x4000) {
        writeChar(1, "This number must be < 0x4000");
        if (readUse == 0) restoreIgnoreAlarm();
        restoreEchoRegime();
        return -1;
      }
      mem = num | 0x4000;
    }
    if(sc_memorySet(pos, mem) != 0) {
      if (readUse == 0) restoreIgnoreAlarm();
      restoreEchoRegime();
      return -1;
    }
  } else {
    writeChar(2, "Memory cell is 15 bit wide");
    if (readUse == 0) restoreIgnoreAlarm();
    restoreEchoRegime();
    return -1;
  }
  if (readUse == 0) restoreIgnoreAlarm();
  restoreEchoRegime();
  return 0;
}

int changeAccumulator(int pos){
  int plusFlag = 0, num = 0;
  setIgnoreAlarm();
  setEchoRegime();
  refreshGui(pos);
  mt_gotoXY(1, 23);
  printLine(2);
  mt_gotoXY(1, 23);
  writeChar(1, "Change Accum: ");
  if (scanNum(&plusFlag, &num) != 0) {
    writeChar(2, "Not a number!");
    restoreEchoRegime();
    restoreIgnoreAlarm();
    return -1;
  }
  if ((num >= 0) & (num < 0x4000)) {
    accumulator = num;
  } else {
    writeChar(2, "Accumutalor is 15 bit wide");
    restoreEchoRegime();
    restoreIgnoreAlarm();
    return -1;
  }
  restoreEchoRegime();
  restoreIgnoreAlarm();
  return 0;
}

int changeInstructionPointer(int pos){
  int plusFlag = 0, num = 0;
  setIgnoreAlarm();
  setEchoRegime();
  refreshGui(pos);
  mt_gotoXY(1, 23);
  printLine(2);
  mt_gotoXY(1, 23);
  writeChar(1, "Change Pointer: ");
  if (scanNum(&plusFlag, &num) != 0) {
    writeChar(2, "Not a number!");
    restoreEchoRegime();
    restoreIgnoreAlarm();
    return -1;
  }
  if ((num >= 0) & (num < sizeRAM)) {
    instructionPointer = num;
  } else {
    writeChar(2, "Instruction Pointer range: from 0 to 99 (0x63)");
    restoreEchoRegime();
    restoreIgnoreAlarm();
    return -1;
  }
  restoreEchoRegime();
  restoreIgnoreAlarm();
  return 0;
}

int scanNum(int *plusFlag, int *n){
  char buffer[SIZE_BUFFER] = {0};
  int pos = 0, i = 0;
  setIgnoreAlarm();
  setEchoRegime();
  do {
    read(0, &buffer[i++], 1);
  } while (buffer[i - 1] != '\n');
  buffer[i - 1] = '\0';
  if (buffer[0] == '+') {
    pos = 1;
    *plusFlag = 1;
  } else {
     pos = 0;
    *plusFlag = 0;
  }
  if (sreadInt(buffer + pos, n, SCANPRINTRADIX) != 1) {
    restoreEchoRegime();
    restoreIgnoreAlarm();
    return -1;
  }
  restoreEchoRegime();
  restoreIgnoreAlarm();
  return 0;
}

int memorySave(int position){
  char filename[SIZE_BUFFER] = {0};
  int i = 0;
  setIgnoreAlarm();
  setEchoRegime();
  refreshGui(position);
  mt_gotoXY(1, 23);
  printLine(2);
  mt_gotoXY(1, 23);
  writeChar(1, "Enter save file name: ");
  do {
    read(0, &filename[i++], 1);
  } while (filename[i - 1] != '\n');
  filename[i - 1] = '\0';
  if (sc_memorySave(filename) == 0) {
    refreshGui(position);
    writeChar(1,"File successfully saved.\n");
    restoreEchoRegime();
    restoreIgnoreAlarm();
    return 0;
  } else {
    writeChar(1,"Cannot save file: ");
    writeChar(1, filename);
    writeChar(1,"\n");
    restoreEchoRegime();
    restoreIgnoreAlarm();
    return -1;
  }
  restoreEchoRegime();
  restoreIgnoreAlarm();
  return 0;
}

int memoryLoad(int position){
  char filename[SIZE_BUFFER] = {0};
  int i = 0, err = 0;
  setIgnoreAlarm();
  setEchoRegime();
  refreshGui(position);
  mt_gotoXY(1, 23);
  printLine(2);
  mt_gotoXY(1, 23);
  writeChar(1, "Enter load file name: ");
  do {
    read(0, &filename[i++], 1);
  } while (filename[i - 1] != '\n');
  filename[i - 1] = '\0';
  char* ptr1 = strrchr(filename, '.');
  if (ptr1 != NULL) {
    if (strcmp(ptr1, ".sa") == 0) {
      char* ptr = NULL;
      int size = strlen(filename);
      ptr = malloc(sizeof(char) * size);
      for (i = 0; i < size; i++) ptr[i] = filename[i];
      ptr1[1] = 'o';
      ptr1[2] = '\0';
      char* args[3];
      args[0] = NULL;
      args[1] = filename;
      args[2] = ptr;
      if (asmTrans(3, args) == 1) err = 1;  /* 0, file.o file.sa */
      free(ptr);
    } else if (strcmp(ptr1, ".sb") == 0) {
      char src[SIZE_BUFFER];
      char dest[SIZE_BUFFER];
      strcpy(src, filename); /* file.sb */
      strcpy(dest, filename);
      char* ptr = strchr(dest, '.');
      ptr[1] = 's';
      ptr[2] = 'a';
      ptr[3] = '\0';
      char *argp[3] = {NULL, dest, src};
      if (basicTrans(3, argp) == 1) { /* 0, file.sa file.sb */
        err = 1;
      } else {
        ptr = strchr(src, '.');
        ptr[1] = 's';
        ptr[2] = 'a';
        ptr[3] = '\0';
        ptr = strchr(dest, '.');
        ptr[1] = 'o';
        ptr[2] = '\0';
        argp[1] = dest;
        argp[2] = src;
        if (asmTrans(3, argp) == 1) {
          err = 1;  /* 0, file.o file.sa */
        } else {
          ptr = strchr(filename, '.');
          ptr[1] = 'o';
          ptr[2] = '\0';
        }
      }
    }
  }

  if (!err) {
    if (sc_memoryLoad(filename) == 0) {
      refreshGui(position);
      writeChar(1, "File successfully loaded\n");
      restoreEchoRegime();
      restoreIgnoreAlarm();
      return 0;
    } else {
      writeChar(1,"Cannot load file: ");
      writeChar(1, filename);
      writeChar(1,"\n");
      restoreEchoRegime();
      restoreIgnoreAlarm();
      return -1;
    }
  } else if (err) {
    writeChar(1,"Cannot load file: ");
    writeChar(1, filename);
    writeChar(1,"\n");
    restoreEchoRegime();
    restoreIgnoreAlarm();
    return -1;
  }
  restoreEchoRegime();
  restoreIgnoreAlarm();
  return 0;
}
----------------read.c----------------
#include "./../include/cpu.h"

extern int instructionPointer;
extern int readUse;

int readMcell(int pos){
  int plusFlag = 0, num = 0, ret = 0, command = 0, operand = 0, mem = 0;
  setEchoRegime();
  refreshGui(pos);
  mt_gotoXY(1, 23);
  printLine(3);
  mt_gotoXY(1, 23);
  writeChar(1,"READ: ");
  mt_gotoXY(1, 24);
  readUse = 1;
  ret = changeCell(pos);
  readUse = 0;
  restoreEchoRegime();
  return ret;
}
----------------cpu.h----------------
#ifndef CPU_H
#define CPU_H

#include "./../../simpleComputer/include/sc_register.h"
#include "./../../simpleComputer/include/sc_command.h"
#include "./../../simpleComputer/include/sc_memory.h"
#include "./../../consoleSC/include/term.h"
#include "./../../bc/include/bc.h"
#include "./../../readKey/include/readkey.h"
#include "./../../print/include/write.h"
#include "./../../scan/include/readInt.h"
#include "./../../asm/include/asm.h"
#include "./../../basic/include/basic.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <signal.h>
#include <fcntl.h>
#include <time.h>
#include <unistd.h>
#include <sys/time.h>

/* CPU */

#ifndef TOKENSYMB
#define TOKENSYMB ' '
#endif

#ifndef TOKENSYMBS
#define TOKENSYMBS " "
#endif

#ifndef SIZE_BUFFER
#define SIZE_BUFFER 256
#endif

#define TIMER ITIMER_REAL
#define REFRESH 500
#define START 1
#define STOP 0

#define BIGCHARSCOLORFG clr_cyan
#define BIGCHARSCOLORBG clr_default
#define TEXTCOLORFG     clr_black
#define TEXTCOLORBG     clr_green
#define FLAGCOLORFG     clr_green
#define KEYCOLORFG      clr_green
#define INSTREGCOLORFG  clr_yellow
#define REGCOLORFG      clr_blue
#define COMMANDCOLORFG  clr_purple
#define OPERANDCOLORFG  clr_light_blue
#define ACCUMCOLORFG    clr_default

#define MKR(X)  (X * 1000000)
#define TIMESLEEPUSEC 0.5
#define TIMESLEEPSEC 0

void CU();
int ALU(int command, int operand);

void frequencyGenerator (int status);

void refreshGuiSt(int position);
void refreshGui(int position);
void printBoxes();
void printPointer();
void printAccum();
void printKeys(int x, int y);
void printLabels();
void printOperation(int position);
void printFlags(int x, int y);
int printMcell(int *bigchars, int pos);
void printLine(int ctr);
void printMemory(int x, int y, int position);

void setSignals();
void signalsRestore();
void setIgnoreAlarm();
void restoreIgnoreAlarm();
void setEchoRegime();
void restoreEchoRegime();

int changeAccumulator(int pos);
int changeInstructionPointer(int pos);
int changeCell(int pos);
int scanNum(int *plusFlag, int *n);

int memorySave(int position);
int memoryLoad(int position);

static void printWriteValue();

int commandHandler(int command, int operand);

int readMcell(int pos);

void timerHand(int sig);
void ursignalHand(int sig);
void ursignalHand2(int sig);
void windHand(int sig);
void killHand(int sig);

#endif
--------libAsm.a--------
----------------asm.c----------------
#include "./../include/asm.h"

int asmTrans(int argc, char** argv){
  if (testArgv(argv) == 1) return 1;
  int input = 0, output = 0, counterTokens = 0, flagign = 0, i = 0;
  int addres = 0, value = 0, ret = 0;
  char buffer[SIZE_BUFFER] = {0};
  int ram[sizeRAM] = {0};
  if ((input = open(argv[2], O_RDONLY)) == -1) return 1;
  if ((output = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, 0666)) == -1) return 1;
  for (i = 0; i < sizeRAM; i++) ram[i] = 0;
  i = 0;
  do {
    value = 0;
    addres = 0;
    int readcount = read(input, &buffer[i], sizeof(char));
    if (readcount == 0) break;
    if (buffer[i] == TOKENSYMB) {
      if (buffer[i - 1] == TOKENSYMB) {
        continue;
      }
    }
    if (buffer[i] == ' ') {
      if (buffer[i - 1] == ' ') {
        continue;
      }
    }
    if (buffer[i] == EOF & flagign == 0) {
      if (counterTokens == 2) {
        buffer[i] = '\0';
        ret = parsingLine(buffer, &addres, &value);
        if (!ret) {
          ram[addres] = value;
        }
      }
      break;
    }
    if (buffer[i] == '\n' & flagign == 1) {
      flagign = 0;
      i = 0;
      counterTokens = 0;
      continue;
    }
    if (flagign == 0) {
      if (buffer[i] == TOKENSYMB & counterTokens < 2) {
        counterTokens++;
        if (counterTokens == 2) {
          i++;
        }
      }
      if (counterTokens == 2 & (buffer[i] == ';' | buffer[i] == '\n'
          | buffer[i] == ' ' | buffer[i] == TOKENSYMB)) {
        if (buffer[i] == ';' | buffer[i] == ' ' | buffer[i] == TOKENSYMB) {
          flagign = 1;
        }
        buffer[i] = '\0';
        ret = parsingLine(buffer, &addres, &value);
        if (ret == 0 | ret == 2) {
          ram[addres] = value;
        }
        counterTokens = 0;
        i = 0;
      }
      i++;
    }
  } while (1);
  write(output, ram, sizeof(int) * sizeRAM);
  close(input);
  close(output);
  return 0;
}

int testArgv(char *argv[]){
  char *ptr1 = NULL;
  char *ptr2 = NULL;
  ptr1 = strrchr(argv[1], '.');
  ptr2 = strrchr(argv[2], '.');
  if ((!(strcmp(ptr1, ".o") == 0)) | (!(strcmp(ptr2, ".sa") == 0))) {
    return 1;
  } else {
    return 0;
  }
}

int asmCommand(char *str){
  int ret = 0;
  if (strcmp(str, "READ") == 0) {
    ret = 0x10;
  } else if (strcmp(str, "WRITE") == 0) {
    ret = 0x11;
  } else if (strcmp(str, "LOAD") == 0) {
    ret = 0x20;
  } else if (strcmp(str, "STORE") == 0) {
    ret = 0x21;
  } else if (strcmp(str, "ADD") == 0) {
    ret = 0x30;
  } else if (strcmp(str, "SUB") == 0) {
    ret = 0x31;
  } else if (strcmp(str, "DIVIDE") == 0) {
    ret = 0x32;
  } else if (strcmp(str, "MUL") == 0) {
    ret = 0x33;
  } else if (strcmp(str, "JUMP") == 0) {
    ret = 0x40;
  } else if (strcmp(str, "JNEG") == 0) {
    ret = 0x41;
  } else if (strcmp(str, "JZ") == 0) {
    ret = 0x42;
  } else if (strcmp(str, "HALT") == 0) {
    ret = 0x43;
  } else if (strcmp(str, "NOT") == 0) {
    ret = 0x51;
  } else if (strcmp(str, "ADD") == 0) {
    ret = 0x52;
  } else if (strcmp(str, "OR") == 0) {
    ret = 0x53;
  } else if (strcmp(str, "XOR") == 0) {
    ret = 0x54;
  } else if (strcmp(str, "JNS") == 0) {
    ret = 0x55;
  } else if (strcmp(str, "JC") == 0) {
    ret = 0x56;
  } else if (strcmp(str, "JNC") == 0) {
    ret = 0x57;
  } else if (strcmp(str, "JP") == 0) {
    ret = 0x58;
  } else if (strcmp(str, "JNP") == 0) {
    ret = 0x59;
  } else if (strcmp(str, "CHL") == 0) {
    ret = 0x60;
  } else if (strcmp(str, "SHR") == 0) {
    ret = 0x61;
  } else if (strcmp(str, "RCL") == 0) {
    ret = 0x62;
  } else if (strcmp(str, "RCR") == 0) {
    ret = 0x63;
  } else if (strcmp(str, "NEG") == 0) {
    ret = 0x64;
  } else if (strcmp(str, "ADDC") == 0) {
    ret = 0x65;
  } else if (strcmp(str, "SUBC") == 0) {
    ret = 0x66;
  } else if (strcmp(str, "LOGLC") == 0) {
    ret = 0x67;
  } else if (strcmp(str, "LOGRC") == 0) {
    ret = 0x68;
  } else if (strcmp(str, "RCCL") == 0) {
    ret = 0x69;
  } else if (strcmp(str, "RCCR") == 0) {
    ret = 0x70;
  } else if (strcmp(str, "MOVA") == 0) {
    ret = 0x71;
  } else if (strcmp(str, "MOVR") == 0) {
    ret = 0x72;
  } else if (strcmp(str, "MOVCA") == 0) {
    ret = 0x73;
  } else if (strcmp(str, "MOVCR") == 0) {
    ret = 0x74;
  } else if (strcmp(str, "ADDCT") == 0) { /* !!! */
    ret = 0x75;
  } else if (strcmp(str, "SUBCT") == 0) { /* !!! */
    ret = 0x76;
  } else {
    ret = -1;
  }
  return ret;
}

int strToCommand(char* ptr, int* value){
  int command = 0, operand = 0, plusFlag = 0, position = 0, tmp = 0;
  if (*ptr == '+') {
    position++;
    plusFlag = 1;
  }
  if (sreadInt(ptr + position, &tmp, 16) != 1) return -1;
  operand = tmp & 0x7F;
  command = (tmp >> 8) & 0x7F;
  sc_commandEncode(command, operand, value);
  if (!plusFlag) {
    *value |= 1 << 14;
  }
  return 0;
}

int parsingLine(char* str, int* addres, int* value){
  char* ptr = str;
  char* tmpPtr    = ptr;
  int command = 0, operand = 0, flagCommand = 0, i = 0;
  while (1) {
    if (tmpPtr[i] == TOKENSYMB) {
      ptr = tmpPtr + i + 1;
      tmpPtr[i] = '\0';
      break;
    }
    i++;
  }
  sreadInt(tmpPtr, addres, 10);
  if (*addres < 0 | *addres > sizeRAM) return -1;
  i = 0;
  tmpPtr = ptr;
  if (*ptr == '=') flagCommand = 1;
  if (flagCommand) {
    while (1) {
      if (tmpPtr[i] == TOKENSYMB) {
        ptr = tmpPtr + i + 1;
        tmpPtr[i] = '\0';
        break;
      }
      i++;
    }
    tmpPtr = ptr + 1;
    if (*tmpPtr == '+') {
      char tmp = tmpPtr[3];
      tmpPtr[3] = '\0';
      sreadInt(tmpPtr + 1, &command, 16);
      tmpPtr[3] = tmp;
      tmpPtr = &tmpPtr[3];
      tmp = tmpPtr[2];
      tmpPtr[2] = '\0';
      sreadInt(tmpPtr, &operand, 16);
      tmpPtr[2] = tmp;
      sc_commandEncode(command, operand, value);
      *value &= 0x7FFF;
    } else {
      sreadInt(tmpPtr, value, 16);
      *value |= (1 << 14);
      *value &= 0x7FFF;
    }
  } else {
    while (1) {
      if (tmpPtr[i] == TOKENSYMB) {
        ptr = tmpPtr + i + 1;
        tmpPtr[i] = '\0';
        break;
      }
      i++;
    }
    command = asmCommand(tmpPtr);
    if (command == -1) return -1;
    i = 0;
    tmpPtr = ptr + 1;
    if (sreadInt(tmpPtr, &operand, 10) == -1) return -1;
    sc_commandEncode(command, operand, value);
  }
  if (command == 0x43) return 2;
  return 0;
}
----------------main.c----------------
#include "./../include/asm.h"

int main(int argc, char *argv[]){
  asmTrans(argc, argv);
  return 0;
}
----------------asm.h----------------
#ifndef ASM_H
#define ASM_H

#include "./../../cpu/include/cpu.h"

int asmTrans(int argc, char** argv);
int asmCommand(char *str);
int parsingLine(char* str, int* addres, int* value);
int strToCommand(char* ptr,int* value);
int testArgv(char* argv[]);

#endif
--------libBasic.a--------
----------------basic.c----------------
#include "./../include/basic.h"

static var alfabet[26];
static memMap map[SIZE_BUFFER];
static int collision   = 0;
static int indexmap    = 0;
static int begin       = 0;
static int end         = 99;
static int tmp         = -1;
static int tmp1        = 0;
static int flagrepeatjump = 0;
static int indexjmp    = 0;
static int flagend    = 0;
static int celljmp     = 0;
static char readc[11]  = "   READ   \n";
static char writec[12] = "   WRITE   \n";
static char jmpc[11]   = "   JUMP   \n";
static char jneg[11]   = "   JNEG   \n";
static char jns[10]    = "   JNS   \n";
static char haltc[11]  = "   HALT   \n";
static char load[11]   = "   LOAD   \n";
static char store[12]  = "   STORE   \n";
static char add[10]    = "   ADD   \n";
static char mul[10]    = "   MUL   \n";
static char divide[13] = "   DIVIDE   \n";
static char sub[10]    = "   SUB   \n";
static char jz[9]      = "   JZ   \n";

int prior(char c) {      
    switch(c) {
        case '(': return 1;
        case '+': case '-': return 2;
        case '*': case '/': return 3;
        default: return 0;
    }
}
void convert(char *str, char *out) {
  int was_op = 0, np = 0, i;    
  int iin = 0, j = 0;
  struct tLEC *p;
  head = malloc(sizeof(struct tLEC));
  head = NULL;
  for(i = 0; i < strlen(str); i++){
    if (((str[i]>= 'A') && (str[i]<='Z'))||((str[i]>= '0')&&(str[i]<= '9'))) {
      out[j] = str[i];
      j++;
      was_op = 0; 
      continue;
    }
    switch (str[i]) {
      case '(': {
        p = calloc(1, sizeof(struct tLEC));
        p->dt=str[i];
        p->next=head;
        head=p; 
        ++np; 
        was_op = 0;
        break;
       }
      case '*': case '/': case '+': case '-':{
        if(!was_op) { 
          was_op = 1;
          p=head;
          while(p!=NULL) {
            if (prior(str[i]) <= prior(p->dt)){
              out[j] = p->dt;
              j++;
              p=p->next;
            }
            else break;
          }
          head=p;
          p = calloc(1, sizeof(struct tLEC));
          p->dt=str[i];
          p->next=head;
          head=p;
        }
        break;
      }
      case ')':{
        if(!was_op) {
          p=head;
          while(p->dt!= '(' && np>0) {
            out[j] = p->dt;
            j++;
            p=p->next;
          }
          p=p->next;
        }
        head=p;
        --np;
        break;
      }
      case ' ': break;
    }
  }
  p=head;
  while(p!=NULL){
    out[j] = p->dt;
    j++;
    p=p->next;
  }
  out[j]='\0';
}

int keywordCode(char *str){
  if (strcmp(str, "REM") == 0) {
    return KEYW_REM;
  } else if (strcmp(str, "INPUT") == 0) {
    return KEYW_INPUT;
  } else if (strcmp(str, "OUTPUT") == 0) {
    return KEYW_OUTPUT;
  } else if (strcmp(str, "GOTO") == 0) {
    return KEYW_GOTO;
  } else if (strcmp(str, "IF") == 0) {
    return KEYW_IF;
  } else if (strcmp(str, "LET") == 0) {
    return KEYW_LET;
  } else if ((strcmp(str, "END") == 0) || (strcmp(str, "END\n") == 0)) {
    return KEYW_END;
  } else {
    return KEYW_E;
  }
}

int basicTrans(int argc, char *argv[]){
  int input = 0, output = 0, readcount;
  char buffer[SIZE_BUFFER] = {0};
  int i = 0, addres = 5, value = 0;
  char *ptr= NULL;
  int ret = 0, BR = 0;
  tmp = -1;
  tmp1 = 0;
  begin = 0;
  end = 99;
  collision = 0;
  indexmap = 0;
  celljmp = 0;
  flagend = 0;
  flagrepeatjump= 0;

  if ((input = open(argv[2], O_RDONLY)) == -1) return 1;
  if ((output = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, 0666)) == -1) return 1;
  for (i = 0; i < 26; i++) {
    alfabet[i].variable = 0;
    alfabet[i].name[0] = 'A' + i;
    alfabet[i].name[1] = '\0';
  }
  for (i = 0; i < SIZE_BUFFER; i++) {
    map[i].real = -1;
    map[i].expect = -1;
  }
  i = 0;
  do {
    readcount = read(input, &buffer[i], sizeof(char));
    if (readcount == 0) break;
    if (buffer[i] == TOKENSYMB) {
      if (buffer[i - 1] == TOKENSYMB) {
        continue;
      }
    }
    if (buffer[i] == ' ') {
      if (buffer[i - 1] == ' ') {
        continue;
      }
    }
    if (buffer[i] == '\n' | (buffer[i] == EOF) ) {
      if (buffer[i] == EOF) {
        BR = 1;
      }
      buffer[i] = '\0';
      ret = parsingLineB(buffer, output);
      BR = ret;
      if (BR == 1) break;
      if (BR == 2) return 1;
      i = -1;
    }
    i++;
  } while (1);
  close(input);
  printf("\n\n\n");
  /*for(i = 0; i < indexmap; i++){
    printf("%d       %d\n", map[i].real, map[i].expect);
  }*/
  close(output);
  if ((output = open(argv[1], O_RDONLY, 0666)) == -1) return 1;
  char c[4096];
  i = 0;
  do {
    readcount = read(output, &c[i++], 1);
  } while (readcount > 0);
  close(output);
  if ((output = open(argv[1], O_WRONLY | O_TRUNC, 0666)) == -1) return 1;
  int j, e, cl = -1;
  for (j = 0; j < i; j++){
    if (0 <= c[j] - '!' && c[j] - '!' <= 9) {
      cl = (c[j] - '!') * 10 + (c[j+1] - '!');
      break;
    }
  }
  for (e = 0; e < indexmap; ++e)
    if (map[e].expect == cl){
     cl = map[e].real;
      break;
    }
  c[j] = cl / 10 + '0';
  c[j + 1] = cl % 10 + '0';
  e = 0;
  while (e < i) {
    write(output,&c[e++],1);
  }
  close(output);
  /*for(i = 0; i < indexmap; i++){
    printf("%d       %d\n", map[i].real, map[i].expect);
  }*/
  //for(j = 0; j < 10000000000; j++);
  return 0;
}

int parsingLineB(char* str, int output){
  char tmpPtr1[256];
  char* ptr    = str;
  char* tmpPtr = ptr;
  char* op     = NULL;
  char* oplet  = NULL;
  int command = 0, operand = 0, i = 0, j = 0, k = 0, q = 0, z = 0;
  int ret = 0, cmp = 0, flagJump = 0, len, sum = 0, sk = 0, lastWrite = 0;
  while (1) {
    if (tmpPtr[i] == TOKENSYMB) {
      ptr = tmpPtr + i + 1;
      tmpPtr[i] = '\0';
      break;
    } else if (tmpPtr[i] == EOF) {
      return 0;
    }
    i++;
  }
  if (!(str[0] >= '0' & str[0] <= '9')) {
    return 0;
  }
  if (tmp1 > 0)
    tmp = tmp1;
    sreadInt(tmpPtr, &tmp1, 10);
    if (tmp1 <= tmp) {
    return 2;
  }

  i = 0;
  tmpPtr = ptr;
  while (1) {
    if (tmpPtr[i] == TOKENSYMB) {
      ptr = tmpPtr + i + 1;
      tmpPtr[i] = '\0';
      break;
    }
    i++;
  }
  ret = keywordCode(tmpPtr);
  tmpPtr = ptr;

  if (ret == KEYW_IF) {
    i = 0;
    while (1) {
      if (tmpPtr[i] == TOKENSYMB) {
        ptr = tmpPtr + i + 1;
        tmpPtr[i] = '\0';
        break;
      }
      i++;
    }
    if (*tmpPtr >= 'A' & *tmpPtr <= 'Z') {
      for (i = 0; i < 26; i++) {
        if (!strcmp(alfabet[i].name, tmpPtr)) {
          if (!(alfabet[i].variable == 1)) {
            return 2;
          }
          tmpPtr = ptr;
          j = 0;
          while (1) {
            if (tmpPtr[j] == TOKENSYMB) {
              ptr = tmpPtr + j + 1;
              tmpPtr[j] = '\0';
              break;
            }
            j++;
          }
          map[indexmap].real = begin;
          map[indexmap].expect = tmp1;
          ++indexmap;
          op = tmpPtr;
          tmpPtr = ptr;
          load[0] = (begin - collision) / 10 + '0';
          load[1] = (begin++ - collision) % 10 + '0';
          load[8] = alfabet[i].cell / 10 + '0';
          load[9] = alfabet[i].cell % 10 + '0';
          write(output, load, sizeof(char) * strlen(load));
          j = 0;
          while (1) {
            if (tmpPtr[j] == TOKENSYMB) {
              ptr = tmpPtr + j + 1;
              tmpPtr[j] = '\0';
              break;
            }
            j++;
          }
          if (*tmpPtr >= 'A' & *tmpPtr <= 'Z') {
            for (j = 0; j < 26; j++) {
              if (!strcmp(alfabet[j].name, tmpPtr)) {
                tmpPtr = ptr;
                if (!(alfabet[j].variable == 1)) {
                  return 2;
                }
                sub[0] = (begin - collision) / 10 + '0';
                sub[1] = (begin++ - collision) % 10 + '0';
                sub[7] = alfabet[j].cell / 10 + '0';
                sub[8] = alfabet[j].cell % 10 + '0';
                write(output, sub, sizeof(char) * strlen(sub));
                break;
              }
            }

          } else {
            int number = atoi(tmpPtr);
            int addr = end--;
            char buf[4];
            swriteInt(buf, number, 16, 4);
            char s = (addr) / 10 + '0';
            write(output, &s, 1);
            s = (addr) % 10 + '0';
            write(output, &s, 1);
            write(output, TOKENSYMBS, 1);
            write(output, "=", 1);
            write(output, TOKENSYMBS, 1);
            write(output, buf, 4);
            write(output, "\n", 1);

            sub[0] = (begin - collision) / 10 + '0';
            sub[1] = (begin++ - collision) % 10 + '0';
            sub[7] = addr / 10 + '0';
            sub[8] = addr % 10 + '0';
            write(output, sub, sizeof(char) * strlen(sub));
          }
        }
      }
    } else {
      int number = atoi(tmpPtr);
      int addr = end--;
      char buf[4];
      swriteInt(buf, number, 16, 4);
      char s = (addr) / 10 + '0';
      write(output, &s, 1);
      s = (addr) % 10 + '0';
      write(output, &s, 1);
      write(output, TOKENSYMBS, 1);
      write(output, "=", 1);
      write(output, TOKENSYMBS, 1);
      write(output, buf, 4);
      write(output, "\n", 1);
      load[0] = (begin - collision) / 10 + '0';
      load[1] = (begin++ - collision) % 10 + '0';
      load[8] = addr / 10 + '0';
      load[9] = addr % 10 + '0';
      write(output, load, sizeof(char) * strlen(load));

      tmpPtr = ptr;
      j = 0;
      while (1) {
        if (tmpPtr[j] == TOKENSYMB) {
          ptr = tmpPtr + j + 1;
          tmpPtr[j] = '\0';
          break;
        }
        j++;
      }
      op = tmpPtr;
      tmpPtr = ptr;
      j = 0;
      while (1) {
        if (tmpPtr[j] == TOKENSYMB) {
          ptr = tmpPtr + j + 1;
          tmpPtr[j] = '\0';
          break;
        }
        j++;
      }
      if (*tmpPtr >= 'A' & *tmpPtr <= 'Z') {
        for (j = 0; j < 26; j++) {
          if (!strcmp(alfabet[j].name, tmpPtr)) {
            tmpPtr = ptr;
            if (!(alfabet[j].variable == 1)) {
              return 2;
            }
            sub[0] = (begin - collision) / 10 + '0';
            sub[1] = (begin++ - collision) % 10 + '0';
            sub[7] = alfabet[j].cell / 10 + '0';
            sub[8] = alfabet[j].cell % 10 + '0';
            write(output, sub, sizeof(char) * strlen(sub));
            break;
          }
        }
      } else {
        number = atoi(tmpPtr);
        addr = end--;
        swriteInt(buf, number, 16, 4);
        char s = (addr) / 10 + '0';
        write(output, &s, 1);
        s = (addr) % 10 + '0';
        write(output, &s, 1);
        write(output, TOKENSYMBS, 1);
        write(output, "=", 1);
        write(output, TOKENSYMBS, 1);
        write(output, buf, 4);
        write(output, "\n", 1);
        sub[0] = (begin - collision) / 10 + '0';
        sub[1] = (begin++ - collision) % 10 + '0';
        sub[7] = addr / 10 + '0';
        sub[8] = addr % 10 + '0';
        write(output, sub, sizeof(char) * strlen(sub));
      }
    }
    tmpPtr = ptr;
    j = 0;
    while (1) {
      if (tmpPtr[j] == TOKENSYMB) {
        ptr = tmpPtr + j + 1;
        tmpPtr[j] = '\0';
        break;
      }
      j++;
    }
    ret = keywordCode(tmpPtr);
    tmpPtr = ptr;
    flagJump = 1;
  }

  if (ret == KEYW_GOTO | (flagrepeatjump == 1 & flagend == 1)) {
    if (flagJump == 1) {
      flagJump = 0;
      int ret = ifoperation(output, op, 0, 0);
      if (ret == -1) {
        return -1;
      }
    }
    jmpc[0] = (begin - collision) / 10 + '0';
    jmpc[1] = (begin - collision) % 10 + '0';
    map[indexmap].real = begin;
    map[indexmap].expect = tmp1;
    ++indexmap;
    int cell = (tmpPtr[0] - '0') * 10 + (tmpPtr[1] - '0');
    for (i = 0; i < indexmap; i++) {
      if ((cell == map[i].expect)) {
        if (map[i].real == -1) {
          return 2;
        }
        cell = map[i].real;
        jmpc[8] = (cell) / 10 + '0';
        jmpc[9] = (cell) % 10 + '0';
        break;
      }
    }
    if (i == indexmap) {
    jmpc[8] = (cell) / 10 + '!';
    jmpc[9] = (cell) % 10 + '!';
    }
      ++begin;
      write(output, jmpc, sizeof(char) * strlen(jmpc));

  }

  if (ret == KEYW_REM) {
    map[indexmap].real = -1;
    map[indexmap].expect = tmp1;
    ++indexmap;
    return 0;
  } else if (ret == KEYW_INPUT) {
    if (flagJump == 1) {
      flagJump = 0;
      int ret = ifoperation(output, op, 0, 0);
      if (ret == -1) {
        return -1;
      }
    }
    for (i = 0; i < 26; i++) {
      if (!strcmp(alfabet[i].name, tmpPtr)) {
        if (end - 1 < begin) {
          return 2;
        }
        alfabet[i].cell = end--;
        if (alfabet[i].variable == 0) {
          alfabet[i].variable = 1;
        }
        map[indexmap].real = begin;
        map[indexmap].expect = tmp1;
        ++indexmap;
        readc[0] = (begin - collision) / 10 + '0';
        readc[1] = (begin++ - collision) % 10 + '0';
        readc[8] = alfabet[i].cell / 10 + '0';
        readc[9] = alfabet[i].cell % 10 + '0';
        write(output, readc, sizeof(char) * strlen(readc));
        break;
      }
    }
  } else if (ret == KEYW_OUTPUT) {
    if (flagJump == 1) {
      flagJump = 0;
      int ret = ifoperation(output, op, 0, 0);
      if (ret == -1) {
        return -1;
      }
    }
    for (i = 0; i < 26; i++) {
      if (!strcmp(alfabet[i].name, tmpPtr)) {
        tmpPtr = ptr;
        if (end - 1 < begin) {
          return 2;
        }

        if (!(alfabet[i].variable == 1)) {
          return 2;
        }
        map[indexmap].real = begin;
        map[indexmap].expect = tmp1;
        ++indexmap;
        writec[0] = (begin - collision) / 10 + '0';
        writec[1] = (begin++ - collision) % 10 + '0';
        writec[9] = alfabet[i].cell / 10 + '0';
        writec[10] = alfabet[i].cell % 10 + '0';
        write(output, writec, sizeof(char) * strlen(writec));
        break;
      }
    }
  } else if (ret == KEYW_LET) {
    len = strlen(ptr);
    for(i = 0; i < len; i++){
      if (ptr[i] == '+' || ptr[i] == '-'||
             ptr[i] == '/'|| ptr[i] == '*') sk++;
    }
    if (flagJump == 1) {
      flagJump = 0;
      int ret = ifoperation(output, op, 1, sk);
      if (ret == -1) return -1;
    }
    j = 0;
    while (1) {
      if (tmpPtr[j] == TOKENSYMB) {
        ptr = tmpPtr + j + 1;
        tmpPtr[j] = '\0';
        break;
      }
      j++;
    }
    for (k = 0; k < 26; k++) {
      if (!strcmp(alfabet[k].name, tmpPtr)) {
        tmpPtr = ptr;
        if (alfabet[k].variable == 0) {
          if (end - 1 < begin) return 2;
          alfabet[k].variable = 1;
          alfabet[k].cell = end--;
        }
        map[indexmap].real = begin;
        map[indexmap].expect = tmp1;
        ++indexmap;
        break;
      }
    }
    j = 0;
    while (1) {
      if (tmpPtr[j] == TOKENSYMB) {
        ptr = tmpPtr + j + 1;
        tmpPtr[j] = '\0';
        break;
      }
      j++;
    }
    if (!(strcmp(tmpPtr, "=") == 0)) return 2;
    convert(ptr, tmpPtr1);
    tmpPtr = ptr;
    len = strlen(tmpPtr1);
    if (sk == 0){
      if (tmpPtr1[0] >= '0' && tmpPtr1[0] <= '9'){
        int number = atoi(&tmpPtr1[0]);
        int addr = end--;
        char buf[4];
        swriteInt(buf, number, 16, 4);
        char s = (addr) / 10 + '0';
        write(output, &s, 1);
        s = (addr) % 10 + '0';
        write(output, &s, 1);
        write(output, TOKENSYMBS, 1);
        write(output, "=", 1);
        write(output, TOKENSYMBS, 1);
        write(output, buf, 4);
        write(output, "\n", 1);
        load[0] = (begin - collision) / 10 + '0';
        load[1] = (begin++ - collision) % 10 + '0';
        load[8] = addr / 10 + '0';
        load[9] = addr % 10 + '0';
        write(output, load, sizeof(char) * strlen(load));
        store[0] = (begin - collision) / 10 + '0';
        store[1] = (begin++ - collision) % 10 + '0';
        store[9] = alfabet[k].cell / 10 + '0';
        store[10] = alfabet[k].cell % 10 + '0';
        write(output, store, sizeof(char) * strlen(store));
      } else if (tmpPtr1[0] >= 'A' && tmpPtr1[0] <= 'Z'){
        for (i = 0; i < 26; i++){
          if (tmpPtr1[0] == alfabet[i].name[0]) break;
        }
        if (i == 26) return 2;
        load[0] = (begin - collision) / 10 + '0';
        load[1] = (begin++ - collision) % 10 + '0';
        load[8] = alfabet[i].cell / 10 + '0';
        load[9] = alfabet[i].cell % 10 + '0';
        write(output, load, sizeof(char) * strlen(load));
        store[0] = (begin - collision) / 10 + '0';
        store[1] = (begin++ - collision) % 10 + '0';
        store[9] = alfabet[k].cell / 10 + '0';
        store[10] = alfabet[k].cell % 10 + '0';
        write(output, store, sizeof(char) * strlen(store));
      } else return 2;
      return 0;
    }
    while(sk != 0){
      long long x, pp;
      //printf("%s\n", tmpPtr1);
     // for(pp = 0; pp < 9000000000; pp++);
      int kk = 0;
      for(i = 0; i < len; i++){
        if (tmpPtr1[i] == '+' || tmpPtr1[i] == '-' ||
               tmpPtr1[i] == '*' || tmpPtr1[i] == '/') break;
      }
      for (j = 0; j < 26; j++){
        if (alfabet[j].name[0] == tmpPtr1[i-2]){
          break;
        }
      }
      for (q = 0; q < 26; q++){
        if (alfabet[q].name[0] == tmpPtr1[i-1]){
          break;
        }
      }
      if (alfabet[j].variable == 1 && alfabet[q].variable == 1) {
        load[0] = (begin - collision) / 10 + '0';
        load[1] = (begin++ - collision) % 10 + '0';
        load[8] = alfabet[j].cell / 10 + '0';
        load[9] = alfabet[j].cell % 10 + '0';
        write(output, load, sizeof(char) * strlen(load));
        switch(tmpPtr1[i]) {
          case '+': {
            add[0] = (begin - collision) / 10 + '0';
            add[1] = (begin++ - collision) % 10 + '0';
            add[7] = alfabet[q].cell / 10 + '0';
            add[8] = alfabet[q].cell % 10 + '0';
            write(output, add, sizeof(char) * strlen(add));
            break;
          }
          case '-': {
            sub[0] = (begin - collision) / 10 + '0';
            sub[1] = (begin++ - collision) % 10 + '0';
            sub[7] = alfabet[q].cell / 10 + '0';
            sub[8] = alfabet[q].cell % 10 + '0';
            write(output, sub, sizeof(char) * strlen(sub));
            break;
          }
          case '*': {
            mul[0] = (begin - collision) / 10 + '0';
            mul[1] = (begin++ - collision) % 10 + '0';
            mul[7] = alfabet[q].cell / 10 + '0';
            mul[8] = alfabet[q].cell % 10 + '0';
            write(output, mul, sizeof(char) * strlen(mul));
            break;
          }
          case '/': {
            divide[0] = (begin - collision) / 10 + '0';
            divide[1] = (begin++ - collision) % 10 + '0';
            divide[10] = alfabet[q].cell / 10 + '0';
            divide[11] = alfabet[q].cell % 10 + '0';
            write(output, divide, sizeof(char) * strlen(divide));
            break;
          }
        }
        for (z = 25; z > 0; z--) {
          if (alfabet[z].variable == 0) {
            if (end - 1 < begin) return 2;
            alfabet[z].variable = 1;
            alfabet[z].cell = end--;
            map[indexmap].real = begin;
            map[indexmap].expect = tmp1;
            ++indexmap;
            break;
          }
        }
        store[0] = (begin - collision) / 10 + '0';
        store[1] = (begin++ - collision) % 10 + '0';
        store[9] = alfabet[z].cell / 10 + '0';
        store[10] = alfabet[z].cell % 10 + '0';
        lastWrite = z;
        write(output, store, sizeof(char) * strlen(store));
        tmpPtr1[i] = alfabet[z].name[0];
        tmpPtr1[i-1] = '!';
        tmpPtr1[i-2] = '!';
        len = strlen(tmpPtr1);
        for(int p = 0; p < 10; p++)
          for(j = 0; j < len; j++){
            if(tmpPtr1[j] == '!'){
              len--;
              for(kk = j; kk < len; kk++){
                tmpPtr1[kk] = tmpPtr1[kk+1]; 
              }
              tmpPtr1[kk] = '\0';
            }
          }
      sk--;
      }else if (!(alfabet[j].variable == 1) && alfabet[q].variable == 1){
        int number = atoi(&tmpPtr1[i-2]);
        int addr = end--;
        char buf[4];
        swriteInt(buf, number, 16, 4);
        char s = (addr) / 10 + '0';
        write(output, &s, 1);
        s = (addr) % 10 + '0';
        write(output, &s, 1);
        write(output, TOKENSYMBS, 1);
        write(output, "=", 1);
        write(output, TOKENSYMBS, 1);
        write(output, buf, 4);
        write(output, "\n", 1);
        load[0] = (begin - collision) / 10 + '0';
        load[1] = (begin++ - collision) % 10 + '0';
        load[8] = addr / 10 + '0';
        load[9] = addr % 10 + '0';
        write(output, load, sizeof(char) * strlen(load));
        switch(tmpPtr1[i]) {
          case '+': {
            add[0] = (begin - collision) / 10 + '0';
            add[1] = (begin++ - collision) % 10 + '0';
            add[7] = alfabet[q].cell / 10 + '0';
            add[8] = alfabet[q].cell % 10 + '0';
            write(output, add, sizeof(char) * strlen(add));
            break;
          }
          case '-': {
            sub[0] = (begin - collision) / 10 + '0';
            sub[1] = (begin++ - collision) % 10 + '0';
            sub[7] = alfabet[q].cell / 10 + '0';
            sub[8] = alfabet[q].cell % 10 + '0';
            write(output, sub, sizeof(char) * strlen(sub));
            break;
          }
          case '*': {
            mul[0] = (begin - collision) / 10 + '0';
            mul[1] = (begin++ - collision) % 10 + '0';
            mul[7] = alfabet[q].cell / 10 + '0';
            mul[8] = alfabet[q].cell % 10 + '0';
            write(output, mul, sizeof(char) * strlen(mul));
            break;
          }
          case '/': {
            divide[0] = (begin - collision) / 10 + '0';
            divide[1] = (begin++ - collision) % 10 + '0';
            divide[10] = alfabet[q].cell / 10 + '0';
            divide[11] = alfabet[q].cell % 10 + '0';
            write(output, divide, sizeof(char) * strlen(divide));
            break;
          }
        }
        for (z = 25; z > 0; z--) {
          if (alfabet[z].variable == 0) {
            if (end - 1 < begin) return 2;
            alfabet[z].variable = 1;
            alfabet[z].cell = end--;
            map[indexmap].real = begin;
            map[indexmap].expect = tmp1;
            ++indexmap;
            break;
          }
        }
        store[0] = (begin - collision) / 10 + '0';
        store[1] = (begin++ - collision) % 10 + '0';
        store[9] = alfabet[z].cell / 10 + '0';
        store[10] = alfabet[z].cell % 10 + '0';
        lastWrite = z;
        write(output, store, sizeof(char) * strlen(store));
        tmpPtr1[i] = alfabet[z].name[0];
        tmpPtr1[i-1] = '!';
        tmpPtr1[i-2] = '!';
        len = strlen(tmpPtr1);
        for(int p = 0; p < 10; p++)
          for(j = 0; j < len; j++){
            if(tmpPtr1[j] == '!'){
              len--;
              for(kk = j; kk < len; kk++){
                tmpPtr1[kk] = tmpPtr1[kk+1]; 
              }
              tmpPtr1[kk] = '\0';
            }
          }
      sk--; 
      }else if (!(alfabet[q].variable == 1) && alfabet[j].variable == 1){
        load[0] = (begin - collision) / 10 + '0';
        load[1] = (begin++ - collision) % 10 + '0';
        load[8] = alfabet[j].cell / 10 + '0';
        load[9] = alfabet[j].cell % 10 + '0';
        write(output, load, sizeof(char) * strlen(load));
        int number = atoi(&tmpPtr1[i-1]);
        int addr = end--;
        char buf[4];
        swriteInt(buf, number, 16, 4);
        char s = (addr) / 10 + '0';
        write(output, &s, 1);
        s = (addr) % 10 + '0';
        write(output, &s, 1);
        write(output, TOKENSYMBS, 1);
        write(output, "=", 1);
        write(output, TOKENSYMBS, 1);
        write(output, buf, 4);
        write(output, "\n", 1);
        write(output, load, sizeof(char) * strlen(load));
        switch(tmpPtr1[i]) {
          case '+': {
            add[0] = (begin - collision) / 10 + '0';
            add[1] = (begin++ - collision) % 10 + '0';
            add[7] = addr / 10 + '0';
            add[8] = addr % 10 + '0';
            write(output, add, sizeof(char) * strlen(add));
            break;
          }
          case '-': {
            sub[0] = (begin - collision) / 10 + '0';
            sub[1] = (begin++ - collision) % 10 + '0';
            sub[7] = addr / 10 + '0';
            sub[8] = addr % 10 + '0';
            write(output, sub, sizeof(char) * strlen(sub));
            break;
          }
          case '*': {
            mul[0] = (begin - collision) / 10 + '0';
            mul[1] = (begin++ - collision) % 10 + '0';
            mul[7] = addr / 10 + '0';
            mul[8] = addr % 10 + '0';
            write(output, mul, sizeof(char) * strlen(mul));
            break;
          }
          case '/': {
            divide[0] = (begin - collision) / 10 + '0';
            divide[1] = (begin++ - collision) % 10 + '0';
            divide[10] = addr / 10 + '0';
            divide[11] = addr % 10 + '0';
            write(output, divide, sizeof(char) * strlen(divide));
            break;
          }
        }
        for (z = 25; z > 0; z--) {
          if (alfabet[z].variable == 0) {
            if (end - 1 < begin) return 2;
            alfabet[z].variable = 1;
            alfabet[z].cell = end--;
            map[indexmap].real = begin;
            map[indexmap].expect = tmp1;
            ++indexmap;
            break;
          }
        }
        store[0] = (begin - collision) / 10 + '0';
        store[1] = (begin++ - collision) % 10 + '0';
        store[9] = alfabet[z].cell / 10 + '0';
        store[10] = alfabet[z].cell % 10 + '0';
        lastWrite = z;
        write(output, store, sizeof(char) * strlen(store));
        tmpPtr1[i] = alfabet[z].name[0];
        tmpPtr1[i-1] = '!';
        tmpPtr1[i-2] = '!';
        len = strlen(tmpPtr1);
        for(int p = 0; p < 10; p++)
          for(j = 0; j < len; j++){
            if(tmpPtr1[j] == '!'){
              len--;
              for(kk = j; kk < len; kk++){
                tmpPtr1[kk] = tmpPtr1[kk+1]; 
              }
              tmpPtr1[kk] = '\0';
            }
          }
        sk--;
      } else {
          char l = tmpPtr1[i-2];
          int number = atoi(&l);
          int addr = end--;
          char buf[4];
          swriteInt(buf, number, 16, 4);
          char s = (addr) / 10 + '0';
          write(output, &s, 1);
          s = (addr) % 10 + '0';
          write(output, &s, 1);
          write(output, TOKENSYMBS, 1);
          write(output, "=", 1);
          write(output, TOKENSYMBS, 1);
          write(output, buf, 4);
          write(output, "\n", 1);
          load[0] = (begin - collision) / 10 + '0';
          load[1] = (begin++ - collision) % 10 + '0';
          load[8] = addr / 10 + '0';
          load[9] = addr % 10 + '0';
          write(output, load, sizeof(char) * strlen(load));
          char ll = tmpPtr1[i-1];
          number = atoi(&ll);
          addr = end--;
          swriteInt(buf, number, 16, 4);
          s = (addr) / 10 + '0';
          write(output, &s, 1);
          s = (addr) % 10 + '0';
          write(output, &s, 1);
          write(output, TOKENSYMBS, 1);
          write(output, "=", 1);
          write(output, TOKENSYMBS, 1);
          write(output, buf, 4);
          write(output, "\n", 1);
          switch(tmpPtr1[i]) {
            case '+': {
              add[0] = (begin - collision) / 10 + '0';
              add[1] = (begin++ - collision) % 10 + '0';
              add[7] = addr / 10 + '0';
              add[8] = addr % 10 + '0';
              write(output, add, sizeof(char) * strlen(add));
              break;
            }
            case '-': {
              sub[0] = (begin - collision) / 10 + '0';
              sub[1] = (begin++ - collision) % 10 + '0';
              sub[7] = addr / 10 + '0';
              sub[8] = addr % 10 + '0';
              write(output, sub, sizeof(char) * strlen(sub));
              break;
            }
            case '*': {
              mul[0] = (begin - collision) / 10 + '0';
              mul[1] = (begin++ - collision) % 10 + '0';
              mul[7] = addr / 10 + '0';
              mul[8] = addr % 10 + '0';
              write(output, mul, sizeof(char) * strlen(mul));
              break;
            }
            case '/': {
              divide[0] = (begin - collision) / 10 + '0';
              divide[1] = (begin++ - collision) % 10 + '0';
              divide[10] = addr / 10 + '0';
              divide[11] = addr % 10 + '0';
              write(output, divide, sizeof(char) * strlen(divide));
              break;
            }
          }
          for (z = 25; z > 0; z--) {
            if (alfabet[z].variable == 0) {
              if (end - 1 < begin) return 2;
              alfabet[z].variable = 1;
              alfabet[z].cell = end--;
              map[indexmap].real = begin;
              map[indexmap].expect = tmp1;
              ++indexmap;
              break;
            }
          }
          store[0] = (begin - collision) / 10 + '0';
          store[1] = (begin++ - collision) % 10 + '0';
          store[9] = alfabet[z].cell / 10 + '0';
          store[10] = alfabet[z].cell % 10 + '0';
          lastWrite = z;
          write(output, store, sizeof(char) * strlen(store));
          tmpPtr1[i] = alfabet[z].name[0];
          tmpPtr1[i-1] = '!';
          tmpPtr1[i-2] = '!';
          len = strlen(tmpPtr1);
          for(int p=0; p < 10; p++)
            for(j = 0; j < len; j++){
              if(tmpPtr1[j] == '!'){
                len--;
                for(kk = j; kk < len; kk++){
                  tmpPtr1[kk] = tmpPtr1[kk+1]; 
                }
                tmpPtr1[kk] = '\0';
              }
            }
          sk--;
      }
    }
    load[0] = (begin - collision) / 10 + '0';
    load[1] = (begin++ - collision) % 10 + '0';
    load[8] = alfabet[lastWrite].cell / 10 + '0';
    load[9] = alfabet[lastWrite].cell % 10 + '0';
    write(output, load, sizeof(char) * strlen(load));
    store[0] = (begin - collision) / 10 + '0';
    store[1] = (begin++ - collision) % 10 + '0';
    store[9] = alfabet[k].cell / 10 + '0';
    store[10] = alfabet[k].cell % 10 + '0';
    write(output, store, sizeof(char) * strlen(store));    
    if (k == 26) return 2;
  } else if (ret == KEYW_END) {
    flagend = 1;
    if (flagJump == 1) {
      flagJump = 0;
      int ret = ifoperation(output, op, 0, 0);
      if (ret == -1) {
        return -1;
      }
    }
    map[indexmap].real = begin;
    map[indexmap].expect = tmp1;
    ++indexmap;
    haltc[0] = (begin - collision) / 10 + '0';
    haltc[1] = (begin++ - collision) % 10 + '0';
    haltc[8] = '0';
    haltc[9] = '0';
    write(output, haltc, sizeof(char) * strlen(haltc));
    return 0;
  } else if (ret == KEYW_E) {
    return 0;
  }
  return 0;
}

int ifoperation(int output, char* op, int let, int zn){
  if (let == 0) {
    if (!strcmp(op, ">")) {
      jz[0] = (begin - collision) / 10 + '0';
      jz[1] = (begin - collision) % 10 + '0';
      jz[6] = (begin + 3) / 10 + '0';
      jz[7] = (begin++ + 3) % 10 + '0';
      write(output, jz, sizeof(char) * strlen(jz));
      jneg[0] = (begin - collision) / 10 + '0';
      jneg[1] = (begin - collision) % 10 + '0';
      jneg[8] = (begin + 2) / 10 + '0';
      jneg[9] = (begin++ + 2) % 10 + '0';
      write(output, jneg, sizeof(char) * strlen(jneg));
      return 0;
    } else if (!strcmp(op, "<")) {
      jns[0] = (begin - collision) / 10 + '0';
      jns[1] = (begin - collision) % 10 + '0';
      jns[7] = (begin + 3) / 10 + '0';
      jns[8] = (begin++ + 3) % 10 + '0';
      write(output, jns, sizeof(char) * strlen(jns));
      jz[0] = (begin - collision) / 10 + '0';
      jz[1] = (begin - collision) % 10 + '0';
      jz[6] = (begin + 2) / 10 + '0';
      jz[7] = (begin++ + 2) % 10 + '0';
      write(output, jz, sizeof(char) * strlen(jz));
      return 0;
    } else if (!strcmp(op, "=")) {
      jneg[0] = (begin - collision) / 10 + '0';
      jneg[1] = (begin - collision) % 10 + '0';
      jneg[8] = (begin + 3) / 10 + '0';
      jneg[9] = (begin++ + 3) % 10 + '0';
      write(output, jneg, sizeof(char) * strlen(jneg));
      jns[0] = (begin - collision) / 10 + '0';
      jns[1] = (begin - collision) % 10 + '0';
      jns[7] = (begin + 2) / 10 + '0';
      jns[8] = (begin++ + 2) % 10 + '0';
      write(output, jns, sizeof(char) * strlen(jns));
      return 0;
    } else {
      return 1;
    }
  } else if (let == 1) {
      if (!strcmp(op, ">")) {
        jz[0] = (begin - collision) / 10 + '0';
        jz[1] = (begin - collision) % 10 + '0';
        jz[6] = (begin + (3 * zn + 4)) / 10 + '0';
        jz[7] = (begin++ + (3 * zn + 4)) % 10 + '0';
        write(output, jz, sizeof(char) * strlen(jz));
        jneg[0] = (begin - collision) / 10 + '0';
        jneg[1] = (begin - collision) % 10 + '0';
        jneg[8] = (begin + (3 * zn + 3)) / 10 + '0';
        jneg[9] = (begin++ + (3 * zn + 3)) % 10 + '0';
        write(output, jneg, sizeof(char) * strlen(jneg));
        return 0;
      } else if (!strcmp(op, "<")) {
        jns[0] = (begin - collision) / 10 + '0';
        jns[1] = (begin - collision) % 10 + '0';
        jns[7] = (begin + (3 * zn + 4)) / 10 + '0';
        jns[8] = (begin++ + (3 * zn + 4)) % 10 + '0';
        write(output, jns, sizeof(char) * strlen(jns));
        jz[0] = (begin - collision) / 10 + '0';
        jz[1] = (begin - collision) % 10 + '0';
        jz[6] = (begin + (3 * zn + 3)) / 10 + '0';
        jz[7] = (begin++ + (3 * zn + 3)) % 10 + '0';
        write(output, jz, sizeof(char) * strlen(jz));
        return 0;
      } else if (!strcmp(op, "=")) {
        jneg[0] = (begin - collision) / 10 + '0';
        jneg[1] = (begin - collision) % 10 + '0';
        jneg[8] = (begin + (3 * zn + 4)) / 10 + '0';
        jneg[9] = (begin++ + (3 * zn + 4)) % 10 + '0';
        write(output, jneg, sizeof(char) * strlen(jneg));
        jns[0] = (begin - collision) / 10 + '0';
        jns[1] = (begin - collision) % 10 + '0';
        jns[7] = (begin + (3 * zn + 3)) / 10 + '0';
        jns[8] = (begin++ + (3 * zn + 3)) % 10 + '0';
        write(output, jns, sizeof(char) * strlen(jns));
        return 0;
      } else {
        return 1;
      }
  }
}
----------------main.c----------------
#include "./../include/basic.h"
#include "./../../asm/include/asm.h"

int main(int argc, char** argv){
  printf("%d %s %s\n", argc, argv[1], argv[2]);
  char dest[SIZE_BUFFER];
  char src[SIZE_BUFFER];
  strcpy(dest, argv[1]);
  strcpy(src, argv[2]);
  char* ptr = strchr(dest, '.');
  ptr[1] = 's';
  ptr[2] = 'a';
  ptr[3] = '\0';
  char *argp[3] = {NULL, dest, src};
  printf("%d %s %s\n", argc, argp[1], argp[2]);
  basicTrans(argc, argp);
  ptr = strchr(src, '.');
  ptr[1] = 's';
  ptr[2] = 'a';
  ptr[3] = '\0';
  ptr = strchr(dest, '.');
  ptr[1] = 'o';
  ptr[2] = '\0';
  argp[1] = dest;
  argp[2] = src;
  printf("%d %s %s\n", argc, dest, src);
  asmTrans(argc, argp);
  return 0;
}
----------------basic.h----------------
#ifndef BASIC_H
#define BASIC_H

#include "./../../print/include/write.h"
#include "./../../cpu/include/cpu.h"
#include <malloc.h>

enum keywords {
  KEYW_REM = 1,
  KEYW_INPUT = 2,
  KEYW_OUTPUT = 3,
  KEYW_GOTO = 4,
  KEYW_IF = 5,
  KEYW_LET = 6,
  KEYW_END = 7,
  KEYW_E = -1
};

struct tLE {
    struct tLE  *next;         
    int  data;      
}*hd;

struct tLEC {
    struct tLEC  *next;         
    char  dt;      
}*head;

typedef struct varBasic {
  char name[2];
  int cell;
  int variable;
} var;

typedef struct memoryMap {
  int real;
  int expect;
} memMap;

int keywordCode(char* str);
int parsingLineB(char* str, int output);
int basicTrans(int argc, char *argv[]);
int ifoperation(int output, char* op, int let, int zn);
void convert(char *str, char *out);
int prior(char c); 

#endif
--------libReadInt.a--------
----------------readInt.c----------------
#include "./../include/readInt.h"

int myPow(int a, int b){
  int tmp = a, i = 0;
  if (b == 0) return 1;
    else if (b == 1) return a;
      else i = 1;
  for (i = 1; i < b; i++) a = a * tmp;
    return a;
  }

int sreadInt(char* buffers, int* num, int radix){
  int size = strlen(buffers) - 1;
  int i = size, k = 0;
  *num = 0;
  for (i = size; i >= 0; i--)
    if ((buffers[i] >= '0') & (buffers[i] <= '9'))
      *num += myPow(radix, k++) * (buffers[i] - '0');
      else if ((buffers[i] >= 'A') & (buffers[i] <= 'F'))
        *num += myPow(radix, k++) * (buffers[i] - 'A' + 10);
        else return -1;
  return 1;
}
----------------readInt.h----------------
#ifndef READ_INT_H
#define READ_INT_H

#include "./../../print/include/write.h"

int sreadInt(char* buffers, int* num, int radix);
int myPow(int a, int b);

#endif
--------libWrite.a--------
----------------write.c----------------
#include "./../include/write.h"

void writeChar(int fd, const char* str){
  write(fd, str, strlen(str));
}

int writeInt(int std, int num, int radix, int znac){
  int i = 0, counter = SIZE_BUFFER;
  char sign = '-';
  char buffer[SIZE_BUFFER] = {0};
  if (num == 0) {
    if (znac == -1) write(std, "0", 1);
    for (i = 0; i < znac; i++) write(std, "0", 1);
    return i;
  }
  if (radix == 10) {
    if (num < 0) {
      write(std, &sign, 1);
      num = -num;
    }
  }
  while (num) {
    if (num % radix > 9) {
      buffer[--counter] = 'A' + num % radix - 10;
      num /= radix;
    } else {
      buffer[--counter] = '0' + (num % radix);
      num /= radix;
    }
  }
  if (znac > -1) {
    if ((SIZE_BUFFER - counter) < znac) {
      znac = znac - SIZE_BUFFER + counter;
      while (znac) {
        write(std, "0", 1);
        znac--;
      }
    }
  }
  write(std, &buffer[counter], SIZE_BUFFER - counter);
  return counter;
}

int swriteInt(char* buff, int num, int radix, int znac){
  char sign = '-', buffer[SIZE_BUFFER] = {0};
  int i = 0, j = 0, k = 0, counter = SIZE_BUFFER;
  if (num == 0) {
    if (znac == -1) buff[i] = '0';
    for (i = 0; i < znac; i++) buff[i] = '0';
    return i;
  }
  if (radix == 10) {
    if (num < 0) {
      buff[0] = sign;
      num = -num;
    }
  }
  while (num) {
    if (num % radix > 9) {
      buffer[--counter] = 'A' + num % radix - 10;
      num /= radix;
    } else {
      buffer[--counter] = '0' + (num % radix);
      num /= radix;
    }
  }
  if (znac > -1) {
    if ((SIZE_BUFFER - counter) < znac) {
      znac = znac - SIZE_BUFFER + counter;
      while (znac) {
        buff[i] = '0';
        i++;
        j++;
        znac--;
      }
    }
  }

  while(i < SIZE_BUFFER - counter + j) {
    buff[i] = buffer[counter + k++];
    i++;
  }

  return counter;
}
----------------write.h----------------
#ifndef WRITE_H
#define WRITE_H

#include <unistd.h>
#include <string.h>

#define SIZE_BUFFER 256

void writeChar(int fd, const char* str);
int writeInt(int std, int num, int radix, int znac);
int swriteInt(char* buff, int num, int radix, int znac);

#endif
